
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>main: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/netabakovv/forum/back/auth_service/cmd/main/main.go (0.0%)</option>
				
				<option value="file1">github.com/netabakovv/forum/back/auth_service/internal/delivery/grpc/handlers/mocks/mock.go (0.0%)</option>
				
				<option value="file2">github.com/netabakovv/forum/back/auth_service/internal/delivery/grpc/handlers/user.go (0.0%)</option>
				
				<option value="file3">github.com/netabakovv/forum/back/auth_service/internal/delivery/grpc/server.go (76.6%)</option>
				
				<option value="file4">github.com/netabakovv/forum/back/auth_service/internal/delivery/http/auth_handler.go (96.4%)</option>
				
				<option value="file5">github.com/netabakovv/forum/back/auth_service/internal/repository/auth.go (83.3%)</option>
				
				<option value="file6">github.com/netabakovv/forum/back/auth_service/internal/repository/mocks/auth_mock.go (89.8%)</option>
				
				<option value="file7">github.com/netabakovv/forum/back/auth_service/internal/service/mocks/token_mocks.go (100.0%)</option>
				
				<option value="file8">github.com/netabakovv/forum/back/auth_service/internal/service/token_service.go (81.8%)</option>
				
				<option value="file9">github.com/netabakovv/forum/back/auth_service/internal/usecase/auth.go (82.9%)</option>
				
				<option value="file10">github.com/netabakovv/forum/back/auth_service/internal/usecase/mocks/auth_mock.go (0.0%)</option>
				
				<option value="file11">github.com/netabakovv/forum/back/forum_service/cmd/main/main.go (0.0%)</option>
				
				<option value="file12">github.com/netabakovv/forum/back/forum_service/internal/delivery/grpc/server.go (0.0%)</option>
				
				<option value="file13">github.com/netabakovv/forum/back/forum_service/internal/delivery/http/handlers.go (0.0%)</option>
				
				<option value="file14">github.com/netabakovv/forum/back/forum_service/internal/delivery/ws/chat.go (0.0%)</option>
				
				<option value="file15">github.com/netabakovv/forum/back/forum_service/internal/repository/forum.go (0.0%)</option>
				
				<option value="file16">github.com/netabakovv/forum/back/forum_service/internal/repository/mocks/repo_mocks.go (100.0%)</option>
				
				<option value="file17">github.com/netabakovv/forum/back/forum_service/internal/service/cleanup.go (91.7%)</option>
				
				<option value="file18">github.com/netabakovv/forum/back/forum_service/internal/service/mocks/service_mocks.go (0.0%)</option>
				
				<option value="file19">github.com/netabakovv/forum/back/forum_service/internal/usecase/forum.go (100.0%)</option>
				
				<option value="file20">github.com/netabakovv/forum/back/forum_service/internal/usecase/mocks/uc_mocks.go (34.8%)</option>
				
				<option value="file21">github.com/netabakovv/forum/back/gateway/cmd/docs/docs.go (100.0%)</option>
				
				<option value="file22">github.com/netabakovv/forum/back/gateway/cmd/main.go (0.0%)</option>
				
				<option value="file23">github.com/netabakovv/forum/back/gateway/internal/delivery/http/middleware.go (0.0%)</option>
				
				<option value="file24">github.com/netabakovv/forum/back/gateway/internal/delivery/http/router.go (0.0%)</option>
				
				<option value="file25">github.com/netabakovv/forum/back/gateway/internal/handler/handlers.go (0.0%)</option>
				
				<option value="file26">github.com/netabakovv/forum/back/pkg/database/migrate.go (0.0%)</option>
				
				<option value="file27">github.com/netabakovv/forum/back/pkg/logger/interface.go (100.0%)</option>
				
				<option value="file28">github.com/netabakovv/forum/back/pkg/logger/mocks/mock.go (63.6%)</option>
				
				<option value="file29">github.com/netabakovv/forum/back/pkg/logger/stdlogger.go (75.0%)</option>
				
				<option value="file30">github.com/netabakovv/forum/back/proto/forum.pb.go (1.3%)</option>
				
				<option value="file31">github.com/netabakovv/forum/back/proto/forum_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "net"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/netabakovv/forum/back/auth_service/internal/delivery/grpc"
        "github.com/netabakovv/forum/back/auth_service/internal/repository"
        "github.com/netabakovv/forum/back/auth_service/internal/service"
        "github.com/netabakovv/forum/back/auth_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/lib/pq"
        "github.com/spf13/viper"
        ggrpc "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        log := logger.NewStdLogger()

        // Инициализация конфигурации
        if err := initConfig(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка инициализации конфига",
                        logger.NewField("error", err))
        }</span>

        // Инициализация репозиториев
        <span class="cov0" title="0">db := initDB(log)
        defer db.Close()

        userRepo := repository.NewUserRepository(db, log)
        tokenRepo := repository.NewTokenRepository(db, log)

        log.Info("репозитории инициализированы успешно")

        // Инициализация сервисов с конфигом
        tokenService := service.NewTokenService(
                viper.GetString("auth.jwt_secret"),
                viper.GetDuration("auth.access_token_ttl"),
                viper.GetDuration("auth.refresh_token_ttl"),
                log,
        )

        log.Info("сервисы инициализированы успешно")

        // Инициализация usecase
        authUC := usecase.NewAuthUsecase(userRepo, tokenRepo, tokenService, log)
        log.Info("use-case'ы инициализированы успешно")

        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        // Запускаем горутину для периодического вызова функции
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                authUC.DeleteExpired(context.Background())</span>
                        }
                }
        }()

        // Инициализация gRPC сервера
        <span class="cov0" title="0">server := grpc.NewAuthServer(authUC, tokenService, log)

        s := ggrpc.NewServer()
        pb.RegisterAuthServiceServer(s, server)

        // Для работы рефлексии (опционально)
        reflection.Register(s)

        // Запуск gRPC сервера
        port := viper.GetString("auth_service.port")
        listener, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось запустить прослушивание порта",
                        logger.NewField("error", err))
        }</span>

        // Graceful shutdown
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info("запуск gRPC сервера на порту",
                        logger.NewField("port", port))
                if err := s.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("ошибка при запуске сервера",
                                logger.NewField("error", err))
                }</span>
        }()

        // Ожидание сигнала для graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("начало graceful shutdown")
        s.GracefulStop()
        log.Info("сервер остановлен")</span>
}

func initConfig() error <span class="cov0" title="0">{
        viper.SetConfigFile("/app/config.yaml")
        return viper.ReadInConfig()
}</span>

func initDB(log logger.Logger) *sql.DB <span class="cov0" title="0">{
        // Используем строку подключения из конфига
        dbURL := viper.GetString("authPath")
        log.Info(dbURL)

        db, err := sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось подключиться к базе данных",
                        logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось проверить соединение с базой данных",
                        logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">log.Info("успешное подключение к базе данных")

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка при инициализации драйвера для базы данных",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file:///app/back/migrations/auth",
                "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка при создании миграций",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                log.Info("ошибка при выполнении миграций",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">log.Info("успешное выполнение миграций")
        return db</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./auth_service/internal/delivery/grpc/handlers/user.go

// Package mocks is a generated GoMock package.
package mocks

import (
        handlers "github.com/netabakovv/forum/back/auth_service/internal/delivery/grpc/handlers"
        logger "github.com/netabakovv/forum/back/pkg/logger"
        proto "github.com/netabakovv/forum/back/proto"
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserServiceClientInterface is a mock of UserServiceClientInterface interface.
type MockUserServiceClientInterface struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceClientInterfaceMockRecorder
}

// MockUserServiceClientInterfaceMockRecorder is the mock recorder for MockUserServiceClientInterface.
type MockUserServiceClientInterfaceMockRecorder struct {
        mock *MockUserServiceClientInterface
}

// NewMockUserServiceClientInterface creates a new mock instance.
func NewMockUserServiceClientInterface(ctrl *gomock.Controller) *MockUserServiceClientInterface <span class="cov0" title="0">{
        mock := &amp;MockUserServiceClientInterface{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceClientInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceClientInterface) EXPECT() *MockUserServiceClientInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockUserServiceClientInterface) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockUserServiceClientInterfaceMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockUserServiceClientInterface)(nil).Close))
}</span>

// GetUserByID mocks base method.
func (m *MockUserServiceClientInterface) GetUserByID(ctx context.Context, userID int64) (*proto.UserProfileResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, userID)
        ret0, _ := ret[0].(*proto.UserProfileResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserServiceClientInterfaceMockRecorder) GetUserByID(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserServiceClientInterface)(nil).GetUserByID), ctx, userID)
}</span>

// NewUserServiceClient mocks base method.
func (m *MockUserServiceClientInterface) NewUserServiceClient(addr string, logger logger.Logger) (*handlers.UserServiceClient, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NewUserServiceClient", addr, logger)
        ret0, _ := ret[0].(*handlers.UserServiceClient)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// NewUserServiceClient indicates an expected call of NewUserServiceClient.
func (mr *MockUserServiceClientInterfaceMockRecorder) NewUserServiceClient(addr, logger interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewUserServiceClient", reflect.TypeOf((*MockUserServiceClientInterface)(nil).NewUserServiceClient), addr, logger)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "fmt"
        "time"

        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
)

type UserServiceClientInterface interface {
        NewUserServiceClient(addr string, logger logger.Logger) (*UserServiceClient, error)
        GetUserByID(ctx context.Context, userID int64) (*pb.UserProfileResponse, error)
        Close() error
}

// UserServiceClient предоставляет клиент для взаимодействия с сервисом пользователей
type UserServiceClient struct {
        client pb.AuthServiceClient
        conn   *grpc.ClientConn
        logger logger.Logger
}

// NewUserServiceClient создает новый экземпляр клиента сервиса пользователей
func NewUserServiceClient(addr string, logger logger.Logger) (*UserServiceClient, error) <span class="cov0" title="0">{
        if addr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("адрес сервера не может быть пустым")
        }</span>
        <span class="cov0" title="0">if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("логгер не может быть nil")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(ctx, addr,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("не удалось подключиться к серверу: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UserServiceClient{
                client: pb.NewAuthServiceClient(conn),
                conn:   conn,
                logger: logger,
        }, nil</span>
}

// GetUserByID получает профиль пользователя по ID
func (c *UserServiceClient) GetUserByID(ctx context.Context, userID int64) (*pb.UserProfileResponse, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("контекст не может быть nil")
        }</span>
        <span class="cov0" title="0">if userID == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID пользователя не может быть пустым")
        }</span>

        <span class="cov0" title="0">c.logger.Info("получение пользователя по ID",
                logger.NewField("user_id", userID),
        )

        resp, err := c.client.GetUserByID(ctx, &amp;pb.GetUserRequest{
                UserId: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                switch status.Code(err) </span>{
                case codes.NotFound:<span class="cov0" title="0">
                        c.logger.Warn("пользователь не найден",
                                logger.NewField("user_id", userID),
                        )
                        return nil, fmt.Errorf("пользователь не найден: %w", err)</span>
                default:<span class="cov0" title="0">
                        c.logger.Error("не удалось получить профиль пользователя",
                                logger.NewField("error", err),
                                logger.NewField("user_id", userID),
                        )
                        return nil, fmt.Errorf("не удалось получить профиль пользователя: %w", err)</span>
                }
        }

        <span class="cov0" title="0">return resp, nil</span>
}

// Close закрывает соединение с сервером
func (c *UserServiceClient) Close() error <span class="cov0" title="0">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("не удалось закрыть соединение",
                        logger.NewField("error", err),
                )
                return fmt.Errorf("не удалось закрыть соединение: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package grpc

import (
        "context"
        "net/http"

        "github.com/netabakovv/forum/back/auth_service/internal/service"
        "github.com/netabakovv/forum/back/auth_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/errors"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type AuthServer struct {
        pb.UnimplementedAuthServiceServer
        authUC       usecase.AuthUsecaseInterface
        tokenService service.TokenServiceInterface
        logger       logger.Logger
}

func NewAuthServer(authUC usecase.AuthUsecaseInterface, tokenService service.TokenServiceInterface, logger logger.Logger) *AuthServer <span class="cov8" title="1">{
        return &amp;AuthServer{
                authUC:       authUC,
                tokenService: tokenService,
                logger:       logger,
        }
}</span>

// Register создает нового пользователя и возвращает токены доступа
func (s *AuthServer) Register(ctx context.Context, req *pb.RegisterRequest) (*pb.RegisterResponse, error) <span class="cov8" title="1">{
        if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                s.logger.Warn("invalid register credentials provided")
                return nil, status.Error(codes.InvalidArgument, "username and password are required")
        }</span>

        <span class="cov8" title="1">tokens, err := s.authUC.Register(ctx, req.Username, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("registration failed",
                        logger.NewField("error", err),
                        logger.NewField("username", req.Username),
                )
                return nil, status.Error(codes.Internal, "failed to register user")
        }</span>

        <span class="cov8" title="1">return &amp;pb.RegisterResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresAt:    tokens.ExpiresAt.Unix(), // используем Unix timestamp
        }, nil</span>
}

// Login аутентифицирует пользователя и возвращает токены доступа
func (s *AuthServer) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) <span class="cov8" title="1">{
        // Проверяем контекст на отмену
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                s.logger.Error("context error",
                        logger.NewField("error", ctx.Err()),
                )
                return nil, status.Error(codes.Canceled, "request canceled")
        }</span>

        <span class="cov8" title="1">s.logger.Info("login request received",
                logger.NewField("username", req.Username),
        )

        if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                s.logger.Warn("invalid login credentials provided")
                return nil, status.Error(codes.InvalidArgument, "username and password are required")
        }</span>

        <span class="cov8" title="1">tokens, user, err := s.authUC.Login(ctx, req.Username, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case errors.ErrInvalidCredentials:<span class="cov8" title="1">
                        s.logger.Warn("invalid credentials",
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.Unauthenticated, "invalid credentials")</span>
                case errors.ErrUserNotFound:<span class="cov8" title="1">
                        s.logger.Warn("user not found",
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.NotFound, "user not found")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("login failed",
                                logger.NewField("error", err),
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.Internal, "internal error")</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info("login successful",
                logger.NewField("username", req.Username),
                logger.NewField("expires_at", tokens.ExpiresAt),
        )

        return &amp;pb.LoginResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresAt:    tokens.ExpiresAt.Unix(),
                User: &amp;pb.UserProfileResponse{
                        UserId:    user.ID,
                        Username:  user.Username,
                        CreatedAt: user.CreatedAt.Unix(),
                        IsAdmin:   user.IsAdmin,
                },
        }, nil</span>
}

func (s *AuthServer) RefreshToken(ctx context.Context, req *pb.RefreshTokenRequest) (*pb.RefreshTokenResponse, error) <span class="cov8" title="1">{
        s.logger.Info("refresh token request received")

        if req.RefreshToken == "" </span><span class="cov8" title="1">{
                s.logger.Warn("empty refresh token provided")
                return nil, status.Error(codes.InvalidArgument, "refresh token is required")
        }</span>

        <span class="cov8" title="1">tokens, err := s.authUC.RefreshTokens(ctx, req.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("RefreshTokens failed", logger.NewField("error", err))
                switch err </span>{
                case errors.ErrTokenInvalid:<span class="cov8" title="1">
                        s.logger.Warn("invalid refresh token")
                        return nil, status.Error(codes.Unauthenticated, "invalid refresh token")</span>
                case errors.ErrTokenExpired:<span class="cov8" title="1">
                        s.logger.Warn("refresh token expired")
                        return nil, status.Error(codes.Unauthenticated, "refresh token expired")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("failed to refresh tokens", logger.NewField("error", err))
                        return nil, status.Error(codes.Internal, "failed to refresh tokens")</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info("tokens refreshed successfully", logger.NewField("new_access", tokens.AccessToken[:10]+"…"))

        return &amp;pb.RefreshTokenResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresAt:    tokens.ExpiresAt.Unix(),
        }, nil</span>
}

func (s *AuthServer) ValidateToken(ctx context.Context, req *pb.ValidateRequest) (*pb.ValidateResponse, error) <span class="cov8" title="1">{
        s.logger.Info("token validation request received")

        if req.AccessToken == "" </span><span class="cov8" title="1">{
                s.logger.Warn("empty token provided")
                return &amp;pb.ValidateResponse{
                        IsValid: false,
                }, status.Error(codes.InvalidArgument, "token is required")
        }</span>

        <span class="cov8" title="1">claims, err := s.tokenService.ValidateToken(req.AccessToken)
        if err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case errors.ErrTokenExpired:<span class="cov8" title="1">
                        s.logger.Warn("token expired")
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.Unauthenticated, "token expired")</span>
                case errors.ErrTokenInvalid:<span class="cov8" title="1">
                        s.logger.Warn("invalid token")
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.InvalidArgument, "invalid token")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("token validation failed",
                                logger.NewField("error", err),
                        )
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.Internal, "internal error")</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info("token validated successfully",
                logger.NewField("user_id", claims.UserID),
        )

        return &amp;pb.ValidateResponse{
                UserId:   claims.UserID, // конвертируем int64 в string
                Username: claims.Username,
                IsAdmin:  claims.IsAdmin,
                IsValid:  true,
        }, nil</span>
}

func (s *AuthServer) Logout(ctx context.Context, req *pb.LogoutRequest) (*pb.LogoutResponse, error) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "контекст не может быть nil")
        }</span>

        <span class="cov8" title="1">if req.AccessToken == "" </span><span class="cov8" title="1">{
                s.logger.Warn("предоставлен пустой токен")
                return nil, status.Error(codes.InvalidArgument, "требуется токен доступа")
        }</span>

        <span class="cov8" title="1">claims, err := s.tokenService.ValidateToken(req.AccessToken)
        if err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case errors.ErrTokenExpired:<span class="cov0" title="0">
                        s.logger.Warn("токен просрочен")
                        return nil, status.Error(codes.Unauthenticated, "токен просрочен")</span>
                case errors.ErrTokenInvalid:<span class="cov8" title="1">
                        s.logger.Warn("недействительный токен")
                        return nil, status.Error(codes.InvalidArgument, "недействительный токен")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("ошибка проверки токена",
                                logger.NewField("error", err),
                        )
                        return nil, status.Error(codes.Internal, "внутренняя ошибка")</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info("получен запрос на выход",
                logger.NewField("user_id", claims.UserID),
        )

        if err := s.authUC.RevokeTokens(ctx, claims.UserID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("не удалось отозвать токены",
                        logger.NewField("error", err),
                        logger.NewField("user_id", claims.UserID),
                )
                return nil, status.Error(codes.Internal, "не удалось выполнить выход")
        }</span>

        <span class="cov8" title="1">s.logger.Info("пользователь успешно вышел",
                logger.NewField("user_id", claims.UserID),
        )

        return &amp;pb.LogoutResponse{
                Success: true,
        }, nil</span>
}

func (s *AuthServer) CheckAdminStatus(ctx context.Context, req *pb.CheckAdminRequest) (*pb.CheckAdminResponse, error) <span class="cov8" title="1">{
        if req.UserId == 0 </span><span class="cov8" title="1">{
                s.logger.Warn("empty user id provided")
                return nil, status.Error(codes.InvalidArgument, "user id is required")
        }</span>

        <span class="cov8" title="1">s.logger.Info("check admin status request received",
                logger.NewField("user_id", req.UserId),
        )

        isAdmin, err := s.authUC.IsAdmin(ctx, req.UserId)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("failed to check admin status",
                        logger.NewField("error", err),
                        logger.NewField("user_id", req.UserId),
                )
                return nil, status.Error(codes.Internal, "failed to check admin status")
        }</span>

        <span class="cov8" title="1">return &amp;pb.CheckAdminResponse{
                IsAdmin: isAdmin,
        }, nil</span>
}

func withCORS(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*") // на время dev можно *
                w.Header().Set("Access-Control-Allow-Headers", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/netabakovv/forum/back/auth_service/internal/usecase"
)

type AuthHandler struct {
        uc usecase.AuthUsecaseInterface
}

func NewAuthHandler(uc usecase.AuthUsecaseInterface) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                uc: uc,
        }
}</span>

func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                Username string `json:"username"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">tokens, err := h.uc.Register(r.Context(), input.Username, input.Password)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                Username string `json:"username"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">tokens, _, err := h.uc.Login(r.Context(), input.Username, input.Password)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var input struct {
                RefreshToken string `json:"refresh_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">tokens, err := h.uc.RefreshTokens(r.Context(), input.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid refresh token", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">json.NewEncoder(w).Encode(tokens)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// repository/auth.go
package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/netabakovv/forum/back/auth_service/internal/entities"
        "github.com/netabakovv/forum/back/pkg/errors"
        "github.com/netabakovv/forum/back/pkg/logger"
)

// UserRepository определяет методы для работы с пользователями в БД
type UserRepository interface {
        Create(ctx context.Context, user *entities.User) error
        GetByID(ctx context.Context, id int64) (*entities.User, error)
        GetByUsername(ctx context.Context, username string) (*entities.User, error)
}

// TokenRepository определяет методы для работы с refresh токенами в БД
type TokenRepository interface {
        Create(ctx context.Context, token *entities.RefreshToken) error
        GetByToken(ctx context.Context, token string) (*entities.RefreshToken, error)
        Revoke(ctx context.Context, token string) error
        DeleteExpired(ctx context.Context) error
        RevokeAllUserTokens(ctx context.Context, userID int64) error
}

// Реализация для PostgreSQL
type userRepo struct {
        db  *sql.DB
        log logger.Logger // Используем интерфейс из пакета logger
}

type tokenRepo struct {
        db  *sql.DB
        log logger.Logger // Используем интерфейс из пакета logger
}

func NewUserRepository(db *sql.DB, logger logger.Logger) UserRepository <span class="cov8" title="1">{
        return &amp;userRepo{
                db:  db,
                log: logger,
        }
}</span>

func NewTokenRepository(db *sql.DB, logger logger.Logger) TokenRepository <span class="cov8" title="1">{
        return &amp;tokenRepo{
                db:  db,
                log: logger,
        }
}</span>

func (r *userRepo) Create(ctx context.Context, user *entities.User) error <span class="cov8" title="1">{ // Изменен возвращаемый тип
        query := `
        INSERT INTO users (username, password_hash, created_at, is_admin)
        VALUES ($1, $2, CURRENT_TIMESTAMP, $3)
        RETURNING id`

        r.log.Info("creating user",
                logger.NewField("username", user.Username),
        )

        err := r.db.QueryRowContext(ctx, query,
                user.Username, user.PasswordHash, user.IsAdmin,
        ).Scan(&amp;user.ID)

        if err != nil </span><span class="cov8" title="1">{
                r.log.Error("failed to create user",
                        logger.NewField("error", err),
                        logger.NewField("username", user.Username),
                )
                return fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *userRepo) GetByID(ctx context.Context, id int64) (*entities.User, error) <span class="cov8" title="1">{
        user := &amp;entities.User{}
        query := `
        SELECT id, username, password_hash, created_at, is_admin
        FROM users 
        WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.PasswordHash, &amp;user.CreatedAt, &amp;user.IsAdmin,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrUserNotFound
        }</span>
        <span class="cov8" title="1">return user, err</span>
}

func (r *userRepo) GetByUsername(ctx context.Context, username string) (*entities.User, error) <span class="cov8" title="1">{
        user := &amp;entities.User{}
        query := `
        SELECT id, username, password_hash, created_at , is_admin
        FROM users 
        WHERE username = $1`
        err := r.db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.PasswordHash, &amp;user.CreatedAt, &amp;user.IsAdmin,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrUserNotFound
        }</span>
        <span class="cov8" title="1">return user, err</span>
}

func (r *tokenRepo) Create(ctx context.Context, token *entities.RefreshToken) error <span class="cov8" title="1">{
        query := `
        INSERT INTO refresh_tokens (user_id, token, expires_at, created_at)
        VALUES ($1, $2, $3, CURRENT_TIMESTAMP)`
        _, err := r.db.ExecContext(ctx, query,
                token.UserID, token.Token, token.ExpiresAt,
        )
        return err
}</span>

func (r *tokenRepo) GetByToken(ctx context.Context, token string) (*entities.RefreshToken, error) <span class="cov8" title="1">{
        rt := &amp;entities.RefreshToken{}
        query := `
        SELECT id, user_id, token, expires_at, created_at 
        FROM refresh_tokens 
        WHERE token = $1`

        r.log.Info("getting refresh token",
                logger.NewField("token", token),
        )

        err := r.db.QueryRowContext(ctx, query, token).Scan(
                &amp;rt.ID, &amp;rt.UserID, &amp;rt.Token, &amp;rt.ExpiresAt, &amp;rt.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to get refresh token",
                        logger.NewField("error", err),
                        logger.NewField("token", token),
                )
                return nil, fmt.Errorf("get refresh token: %w", err)
        }</span>

        <span class="cov8" title="1">return rt, nil</span>
}

func (r *tokenRepo) Revoke(ctx context.Context, token string) error <span class="cov8" title="1">{
        query := `DELETE FROM refresh_tokens WHERE token = $1`
        _, err := r.db.ExecContext(ctx, query, token)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to revoke token",
                        logger.NewField("error", err),
                        logger.NewField("token", token),
                )
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (r *tokenRepo) DeleteExpired(ctx context.Context) error <span class="cov8" title="1">{
        query := `DELETE FROM refresh_tokens WHERE expires_at &lt; NOW()`
        _, err := r.db.ExecContext(ctx, query)
        return err
}</span>

func (r *tokenRepo) RevokeAllUserTokens(ctx context.Context, userID int64) error <span class="cov8" title="1">{
        query := `DELETE FROM refresh_tokens WHERE user_id = $1`
        _, err := r.db.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to revoke user tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./auth_service/internal/repository/auth.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        entities "github.com/netabakovv/forum/back/auth_service/internal/entities"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov8" title="1">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(ctx context.Context, user *entities.User) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), ctx, user)
}</span>

// GetByID mocks base method.
func (m *MockUserRepository) GetByID(ctx context.Context, id int64) (*entities.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", ctx, id)
        ret0, _ := ret[0].(*entities.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockUserRepositoryMockRecorder) GetByID(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockUserRepository)(nil).GetByID), ctx, id)
}</span>

// GetByUsername mocks base method.
func (m *MockUserRepository) GetByUsername(ctx context.Context, username string) (*entities.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUsername", ctx, username)
        ret0, _ := ret[0].(*entities.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUsername indicates an expected call of GetByUsername.
func (mr *MockUserRepositoryMockRecorder) GetByUsername(ctx, username interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUsername", reflect.TypeOf((*MockUserRepository)(nil).GetByUsername), ctx, username)
}</span>

// MockTokenRepository is a mock of TokenRepository interface.
type MockTokenRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTokenRepositoryMockRecorder
}

// MockTokenRepositoryMockRecorder is the mock recorder for MockTokenRepository.
type MockTokenRepositoryMockRecorder struct {
        mock *MockTokenRepository
}

// NewMockTokenRepository creates a new mock instance.
func NewMockTokenRepository(ctrl *gomock.Controller) *MockTokenRepository <span class="cov8" title="1">{
        mock := &amp;MockTokenRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTokenRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenRepository) EXPECT() *MockTokenRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockTokenRepository) Create(ctx context.Context, token *entities.RefreshToken) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockTokenRepositoryMockRecorder) Create(ctx, token interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTokenRepository)(nil).Create), ctx, token)
}</span>

// DeleteExpired mocks base method.
func (m *MockTokenRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteExpired", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteExpired indicates an expected call of DeleteExpired.
func (mr *MockTokenRepositoryMockRecorder) DeleteExpired(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpired", reflect.TypeOf((*MockTokenRepository)(nil).DeleteExpired), ctx)
}</span>

// GetByToken mocks base method.
func (m *MockTokenRepository) GetByToken(ctx context.Context, token string) (*entities.RefreshToken, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByToken", ctx, token)
        ret0, _ := ret[0].(*entities.RefreshToken)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByToken indicates an expected call of GetByToken.
func (mr *MockTokenRepositoryMockRecorder) GetByToken(ctx, token interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByToken", reflect.TypeOf((*MockTokenRepository)(nil).GetByToken), ctx, token)
}</span>

// Revoke mocks base method.
func (m *MockTokenRepository) Revoke(ctx context.Context, token string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Revoke", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Revoke indicates an expected call of Revoke.
func (mr *MockTokenRepositoryMockRecorder) Revoke(ctx, token interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revoke", reflect.TypeOf((*MockTokenRepository)(nil).Revoke), ctx, token)
}</span>

// RevokeAllUserTokens mocks base method.
func (m *MockTokenRepository) RevokeAllUserTokens(ctx context.Context, userID int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevokeAllUserTokens", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RevokeAllUserTokens indicates an expected call of RevokeAllUserTokens.
func (mr *MockTokenRepositoryMockRecorder) RevokeAllUserTokens(ctx, userID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeAllUserTokens", reflect.TypeOf((*MockTokenRepository)(nil).RevokeAllUserTokens), ctx, userID)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: auth_service/internal/service/token_service.go
//
// Generated by this command:
//
//        mockgen -source=auth_service/internal/service/token_service.go -destination=auth_service/internal/service/mocks/token_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "github.com/netabakovv/forum/back/auth_service/internal/entities"
        reflect "reflect"

        gomock  "github.com/golang/mock/gomock"
)

// MockTokenServiceInterface is a mock of TokenServiceInterface interface.
type MockTokenServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockTokenServiceInterfaceMockRecorder
        isgomock struct{}
}

// MockTokenServiceInterfaceMockRecorder is the mock recorder for MockTokenServiceInterface.
type MockTokenServiceInterfaceMockRecorder struct {
        mock *MockTokenServiceInterface
}

// NewMockTokenServiceInterface creates a new mock instance.
func NewMockTokenServiceInterface(ctrl *gomock.Controller) *MockTokenServiceInterface <span class="cov8" title="1">{
        mock := &amp;MockTokenServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockTokenServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenServiceInterface) EXPECT() *MockTokenServiceInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GenerateTokenPair mocks base method.
func (m *MockTokenServiceInterface) GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateTokenPair", userID, username, isAdmin)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GenerateTokenPair indicates an expected call of GenerateTokenPair.
func (mr *MockTokenServiceInterfaceMockRecorder) GenerateTokenPair(userID, username, isAdmin any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateTokenPair", reflect.TypeOf((*MockTokenServiceInterface)(nil).GenerateTokenPair), userID, username, isAdmin)
}</span>

// ValidateToken mocks base method.
func (m *MockTokenServiceInterface) ValidateToken(tokenString string) (*entities.TokenClaims, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateToken", tokenString)
        ret0, _ := ret[0].(*entities.TokenClaims)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ValidateToken indicates an expected call of ValidateToken.
func (mr *MockTokenServiceInterfaceMockRecorder) ValidateToken(tokenString any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateToken", reflect.TypeOf((*MockTokenServiceInterface)(nil).ValidateToken), tokenString)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "fmt"
        "time"

        "github.com/netabakovv/forum/back/auth_service/internal/entities"
        "github.com/netabakovv/forum/back/pkg/logger"

        "github.com/golang-jwt/jwt"
)

const (
        AccessTokenType  = "access"
        RefreshTokenType = "refresh"
)

type TokenService struct {
        secretKey       string
        AccessTokenTTL  time.Duration
        RefreshTokenTTL time.Duration
        logger          logger.Logger
}

type TokenServiceInterface interface {
        GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error)
        ValidateToken(tokenString string) (*entities.TokenClaims, error)
}

func NewTokenService(secretKey string, accessTTL, refreshTTL time.Duration, logger logger.Logger) *TokenService <span class="cov8" title="1">{
        return &amp;TokenService{
                secretKey:       secretKey,
                AccessTokenTTL:  accessTTL,
                RefreshTokenTTL: refreshTTL,
                logger:          logger,
        }
}</span>

func (s *TokenService) GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error) <span class="cov8" title="1">{
        s.logger.Info("generating token pair",
                logger.NewField("user_id", userID),
                logger.NewField("username", username),
        )

        // Генерируем Access Token
        accessToken, err := s.generateToken(userID, username, isAdmin, s.AccessTokenTTL, AccessTokenType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        // Генерируем Refresh Token
        <span class="cov8" title="1">refreshToken, err := s.generateToken(userID, username, isAdmin, s.RefreshTokenTTL, RefreshTokenType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov8" title="1">expiresAt := time.Now().Add(s.AccessTokenTTL)

        return &amp;entities.TokenPair{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresAt:    expiresAt,
        }, nil</span>
}

func (s *TokenService) ValidateToken(tokenString string) (*entities.TokenClaims, error) <span class="cov8" title="1">{
        if tokenString == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty token")
        }</span>

        <span class="cov8" title="1">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(s.secretKey), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if ve, ok := err.(*jwt.ValidationError); ok </span><span class="cov8" title="1">{
                        if ve.Errors&amp;jwt.ValidationErrorExpired != 0 </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("token expired")
                        }</span>
                }
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to parse token: %w", err)</span>
        }

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov8" title="1">userID, ok := claims["user_id"].(float64)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid user_id claim")
        }</span>

        <span class="cov8" title="1">username, ok := claims["username"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username claim")
        }</span>

        <span class="cov8" title="1">isAdmin, ok := claims["is_admin"].(bool)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid is_admin claim")
        }</span>

        <span class="cov8" title="1">tokenType, ok := claims["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token type claim")
        }</span>

        <span class="cov8" title="1">return &amp;entities.TokenClaims{
                UserID:    int64(userID),
                Username:  username,
                IsAdmin:   isAdmin,
                ExpiresAt: int64(claims["exp"].(float64)),
                TokenType: tokenType,
        }, nil</span>
}

func (s *TokenService) generateToken(userID int64, username string, isAdmin bool, expiration time.Duration, tokenType string) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        claims := jwt.MapClaims{
                "user_id":  userID,
                "username": username,
                "is_admin": isAdmin,
                "type":     tokenType,
                "iat":      now.Unix(),
                "exp":      now.Add(expiration).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        signedToken, err := token.SignedString([]byte(s.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov8" title="1">return signedToken, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package usecase

import (
        "context"
        "time"

        "github.com/netabakovv/forum/back/pkg/errors"
        "github.com/netabakovv/forum/back/pkg/logger"

        "github.com/netabakovv/forum/back/auth_service/internal/entities"
        "github.com/netabakovv/forum/back/auth_service/internal/repository"
        "github.com/netabakovv/forum/back/auth_service/internal/service"

        "golang.org/x/crypto/bcrypt"
)

type AuthUsecaseInterface interface {
        Register(ctx context.Context, username, password string) (*entities.TokenPair, error)
        Login(ctx context.Context, username, password string) (*entities.TokenPair, *entities.User, error)
        RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error)
        IsAdmin(ctx context.Context, userID int64) (bool, error)
        RevokeTokens(ctx context.Context, userID int64) error
        Logout(ctx context.Context, refreshToken string) error
        ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error)
}

type LoginResponse struct {
        Tokens *entities.TokenPair
        User   *entities.User
}

type AuthUsecase struct {
        userRepo        repository.UserRepository
        tokenRepo       repository.TokenRepository
        tokenService    service.TokenServiceInterface
        logger          logger.Logger
        RefreshTokenTTL time.Duration
}

func NewAuthUsecase(userRepo repository.UserRepository, tokenRepo repository.TokenRepository, tokenService service.TokenServiceInterface, logger logger.Logger) *AuthUsecase <span class="cov8" title="1">{
        return &amp;AuthUsecase{
                userRepo:        userRepo,
                tokenRepo:       tokenRepo,
                tokenService:    tokenService,
                logger:          logger,
                RefreshTokenTTL: time.Hour * 24 * 30, // 30 days
        }
}</span>

func (uc *AuthUsecase) Login(ctx context.Context, username, password string) (*entities.TokenPair, *entities.User, error) <span class="cov8" title="1">{
        uc.logger.Info("attempting login",
                logger.NewField("username", username),
        )

        user, err := uc.userRepo.GetByUsername(ctx, username)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Warn("failed to get user",
                        logger.NewField("error", err),
                        logger.NewField("username", username),
                )
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if !CheckPasswordHash(password, user.PasswordHash) </span><span class="cov8" title="1">{
                uc.logger.Warn("invalid password attempt",
                        logger.NewField("username", username),
                )
                return nil, nil, errors.ErrWrongPassword
        }</span>

        <span class="cov8" title="1">tokens, err := uc.tokenService.GenerateTokenPair(user.ID, user.Username, user.IsAdmin)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("failed to generate tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    user.ID,
                Token:     tokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("failed to save refresh token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("login successful",
                logger.NewField("user_id", user.ID),
                logger.NewField("username", username),
        )

        return tokens, user, nil</span>
}

func (uc *AuthUsecase) RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error) <span class="cov8" title="1">{
        // Валидируем refresh token
        claims, err := uc.tokenService.ValidateToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenInvalid
        }</span>

        // Проверяем токен в базе
        <span class="cov8" title="1">dbToken, err := uc.tokenRepo.GetByToken(ctx, refreshToken)
        if err != nil || dbToken.Revoked || time.Now().After(dbToken.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenInvalid
        }</span>

        // Генерируем новую пару токенов
        <span class="cov8" title="1">newTokens, err := uc.tokenService.GenerateTokenPair(claims.UserID, claims.Username, claims.IsAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Отзываем старый refresh token
        <span class="cov8" title="1">if err := uc.tokenRepo.Revoke(ctx, refreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Сохраняем новый refresh token
        <span class="cov8" title="1">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    claims.UserID,
                Token:     newTokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newTokens, nil</span>
}

func (uc *AuthUsecase) Register(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov8" title="1">{
        uc.logger.Info("attempting registration",
                logger.NewField("username", username),
        )

        // Проверяем, не существует ли пользователь
        _, err := uc.userRepo.GetByUsername(ctx, username)
        if err == nil </span><span class="cov8" title="1">{
                uc.logger.Warn("user already exists",
                        logger.NewField("username", username),
                )
                return nil, errors.ErrDuplicateUsername
        }</span>

        // Хешируем пароль
        <span class="cov8" title="1">passwordHash, err := HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to hash password",
                        logger.NewField("error", err),
                )
                return nil, err
        }</span>

        // Создаем пользователя
        <span class="cov8" title="1">user := &amp;entities.User{
                Username:     username,
                PasswordHash: passwordHash,
                CreatedAt:    time.Now(),
                IsAdmin:      false,
        }

        err = uc.userRepo.Create(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("failed to create user",
                        logger.NewField("error", err),
                        logger.NewField("username", username),
                )
                return nil, err
        }</span>

        // Генерируем токены
        <span class="cov8" title="1">tokens, err := uc.tokenService.GenerateTokenPair(user.ID, user.Username, user.IsAdmin)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("failed to generate tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        // Сохраняем refresh token
        <span class="cov8" title="1">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    user.ID,
                Token:     tokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("failed to save refresh token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("registration successful",
                logger.NewField("user_id", user.ID),
                logger.NewField("username", username),
        )

        return tokens, nil</span>
}

func (uc *AuthUsecase) IsAdmin(ctx context.Context, userID int64) (bool, error) <span class="cov8" title="1">{
        user, err := uc.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return user.IsAdmin, nil</span>
}

func (uc *AuthUsecase) RevokeTokens(ctx context.Context, userID int64) error <span class="cov8" title="1">{
        uc.logger.Info("attempting to revoke all user tokens",
                logger.NewField("user_id", userID),
        )

        if err := uc.tokenRepo.RevokeAllUserTokens(ctx, userID); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to revoke user tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("successfully revoked all user tokens",
                logger.NewField("user_id", userID),
        )

        return nil</span>
}

func (uc *AuthUsecase) Logout(ctx context.Context, refreshToken string) error <span class="cov8" title="1">{
        return uc.tokenRepo.Revoke(ctx, refreshToken)
}</span>

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func (a *AuthUsecase) ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error) <span class="cov8" title="1">{
        claims, err := a.tokenService.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}

func (a *AuthUsecase) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        a.logger.Info("DELETE EXPIRED TOKENS")
        return a.tokenRepo.DeleteExpired(ctx)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./auth_service/internal/usecase/auth.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        entities "github.com/netabakovv/forum/back/auth_service/internal/entities"
)

// MockAuthUsecaseInterface is a mock of AuthUsecaseInterface interface.
type MockAuthUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockAuthUsecaseInterfaceMockRecorder
}

// MockAuthUsecaseInterfaceMockRecorder is the mock recorder for MockAuthUsecaseInterface.
type MockAuthUsecaseInterfaceMockRecorder struct {
        mock *MockAuthUsecaseInterface
}

// NewMockAuthUsecaseInterface creates a new mock instance.
func NewMockAuthUsecaseInterface(ctrl *gomock.Controller) *MockAuthUsecaseInterface <span class="cov0" title="0">{
        mock := &amp;MockAuthUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockAuthUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthUsecaseInterface) EXPECT() *MockAuthUsecaseInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// IsAdmin mocks base method.
func (m *MockAuthUsecaseInterface) IsAdmin(ctx context.Context, userID int64) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsAdmin", ctx, userID)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsAdmin indicates an expected call of IsAdmin.
func (mr *MockAuthUsecaseInterfaceMockRecorder) IsAdmin(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAdmin", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).IsAdmin), ctx, userID)
}</span>

// Login mocks base method.
func (m *MockAuthUsecaseInterface) Login(ctx context.Context, username, password string) (*entities.TokenPair, *entities.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", ctx, username, password)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(*entities.User)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// Login indicates an expected call of Login.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Login(ctx, username, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Login), ctx, username, password)
}</span>

// Logout mocks base method.
func (m *MockAuthUsecaseInterface) Logout(ctx context.Context, refreshToken string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logout", ctx, refreshToken)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Logout indicates an expected call of Logout.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Logout(ctx, refreshToken interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Logout), ctx, refreshToken)
}</span>

// RefreshTokens mocks base method.
func (m *MockAuthUsecaseInterface) RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RefreshTokens", ctx, refreshToken)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// RefreshTokens indicates an expected call of RefreshTokens.
func (mr *MockAuthUsecaseInterfaceMockRecorder) RefreshTokens(ctx, refreshToken interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokens", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).RefreshTokens), ctx, refreshToken)
}</span>

// Register mocks base method.
func (m *MockAuthUsecaseInterface) Register(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", ctx, username, password)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Register(ctx, username, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Register), ctx, username, password)
}</span>

// RevokeTokens mocks base method.
func (m *MockAuthUsecaseInterface) RevokeTokens(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevokeTokens", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RevokeTokens indicates an expected call of RevokeTokens.
func (mr *MockAuthUsecaseInterfaceMockRecorder) RevokeTokens(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeTokens", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).RevokeTokens), ctx, userID)
}</span>

// ValidateToken mocks base method.
func (m *MockAuthUsecaseInterface) ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateToken", ctx, token)
        ret0, _ := ret[0].(*entities.TokenClaims)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ValidateToken indicates an expected call of ValidateToken.
func (mr *MockAuthUsecaseInterfaceMockRecorder) ValidateToken(ctx, token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateToken", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).ValidateToken), ctx, token)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "database/sql"
        "fmt"
        "net"
        "net/http"

        serv "github.com/netabakovv/forum/back/forum_service/internal/delivery/grpc"
        "github.com/netabakovv/forum/back/forum_service/internal/delivery/ws"
        "github.com/netabakovv/forum/back/forum_service/internal/repository"
        "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/lib/pq"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        log := logger.NewStdLogger()

        if err := initConfig(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка инициализации конфига",
                        logger.NewField("error", err))
        }</span>

        // Инициализация репозиториев
        <span class="cov0" title="0">db := initDB(log)
        defer db.Close()

        // Подключение к auth service
        authConn, err := grpc.Dial(
                fmt.Sprintf("auth_service:%s", viper.GetString("auth_service.port")),
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка подключения к auth service", logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">defer authConn.Close()

        authClient := pb.NewAuthServiceClient(authConn)

        // Репозитории
        postRepo := repository.NewPostRepository(db, log)
        commentRepo := repository.NewCommentRepository(db, log)
        chatRepo := repository.NewChatRepository(db, log)

        // Use cases
        postUC := usecase.NewPostUsecase(postRepo, log)
        commentUC := usecase.NewCommentUsecase(commentRepo, log)
        chatUC := usecase.NewChatUsecase(chatRepo, log, &amp;pb.ChatConfig{
                MessageLifetimeMinutes: 1,
                MaxMessageLength:       1000,
                OnlyAuthenticated:      true})
        cleanup := usecase.NewCleanupService(chatUC, log)
        cleanup.Start(viper.GetDuration("chat.cleanup_interval"), viper.GetDuration("chat.message_lifetime"))
        defer cleanup.Stop()

        // gRPC сервер
        grpcServer := grpc.NewServer()

        // Форум сервер
        forumServer := serv.NewForumServer(authClient, postUC, commentUC, chatUC)
        pb.RegisterForumServiceServer(grpcServer, forumServer)

        // WebSocket чат

        chatHandler := ws.NewChatHandler(chatUC, log, &amp;pb.ChatConfig{
                MessageLifetimeMinutes: 1,
                MaxMessageLength:       1000,
                OnlyAuthenticated:      true,
        }, authClient)
        http.HandleFunc("/ws/chat", chatHandler.HandleWebSocket)

        // Запуск серверов
        go func() </span><span class="cov0" title="0">{
                if err := http.ListenAndServe(":8080", nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("ошибка WebSocket сервера", logger.NewField("error", err))
                }</span>
        }()

        <span class="cov0" title="0">lis, err := net.Listen("tcp", ":50051")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка запуска gRPC сервера", logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка работы gRPC сервера", logger.NewField("error", err))
        }</span>
}

func initConfig() error <span class="cov0" title="0">{
        viper.SetConfigFile("/app/config.yaml")
        return viper.ReadInConfig()
}</span>

func initDB(log logger.Logger) *sql.DB <span class="cov0" title="0">{
        // Используем строку подключения из конфига
        dbURL := viper.GetString("forumPath")
        log.Info(dbURL)

        db, err := sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось подключиться к базе данных",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось проверить соединение с базой данных",
                        logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">log.Info("успешное подключение к базе данных")

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка при инициализации драйвера для базы данных",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file:///app/back/migrations/forum",
                "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка при создании миграций",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                log.Info("ошибка при выполнении миграций",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">return db</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package grpc

import (
        "context"
        "fmt"
        "time"

        "github.com/netabakovv/forum/back/forum_service/internal/entities"
        "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        pb "github.com/netabakovv/forum/back/proto"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ForumServer struct {
        pb.UnimplementedForumServiceServer
        authService pb.AuthServiceClient
        postUC      *usecase.PostUsecase
        commentUC   *usecase.CommentUsecase
        chatUC      *usecase.ChatUsecase
}

// NewForumServer — конструктор (удобно для внедрения зависимостей)
func NewForumServer(
        authService pb.AuthServiceClient,
        postUC *usecase.PostUsecase,
        commentUC *usecase.CommentUsecase,
        chatUC *usecase.ChatUsecase,
) *ForumServer <span class="cov0" title="0">{
        return &amp;ForumServer{
                authService: authService,
                postUC:      postUC,
                commentUC:   commentUC,
                chatUC:      chatUC,
        }
}</span>

// Post operations
func (s *ForumServer) CreatePost(ctx context.Context, req *pb.CreatePostRequest) (*pb.PostResponse, error) <span class="cov0" title="0">{
        if req.Title == "" || req.Content == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "заголовок и содержание обязательны")
        }</span>

        <span class="cov0" title="0">post := &amp;entities.Post{
                Title:        req.Title,
                Content:      req.Content,
                AuthorID:     req.AuthorId,
                AuthorName:   req.AuthorUsername,
                CreatedAt:    time.Now(),
                CommentCount: 0,
        }

        err := s.postUC.CreatePost(ctx, post)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось создать пост")
        }</span>

        <span class="cov0" title="0">return &amp;pb.PostResponse{
                Post: &amp;pb.Post{
                        Id:             post.ID,
                        Title:          post.Title,
                        Content:        post.Content,
                        AuthorId:       post.AuthorID,
                        AuthorUsername: post.AuthorName,
                        CreatedAt:      post.CreatedAt.Unix(),
                        CommentCount:   post.CommentCount,
                },
        }, nil</span>
}

func (s *ForumServer) GetPost(ctx context.Context, req *pb.GetPostRequest) (*pb.PostResponse, error) <span class="cov0" title="0">{
        if req.PostId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор поста обязателен")
        }</span>

        <span class="cov0" title="0">post, err := s.postUC.GetPostByID(ctx, req.PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить пост")
        }</span>

        <span class="cov0" title="0">return &amp;pb.PostResponse{
                Post: &amp;pb.Post{
                        Id:             post.ID,
                        Title:          post.Title,
                        Content:        post.Content,
                        AuthorId:       post.AuthorID,
                        AuthorUsername: post.AuthorName,
                        CreatedAt:      post.CreatedAt.Unix(),
                        CommentCount:   post.CommentCount,
                },
        }, nil</span>
}

func (s *ForumServer) GetByPostID(ctx context.Context, req *pb.GetCommentsByPostIDRequest) (*pb.ListCommentsResponse, error) <span class="cov0" title="0">{
        if req.PostId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор поста обязателен")
        }</span>
        <span class="cov0" title="0">comments, err := s.commentUC.GetByPostID(ctx, req.PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить комментарии")
        }</span>
        <span class="cov0" title="0">protoComments := make([]*pb.Comment, 0, len(comments))
        for _, c := range comments </span><span class="cov0" title="0">{
                protoComments = append(protoComments, &amp;pb.Comment{
                        Id:             c.ID,
                        PostId:         c.PostID,
                        AuthorId:       c.AuthorID,
                        AuthorUsername: c.AuthorName,
                        Content:        c.Content,
                        CreatedAt:      c.CreatedAt.Unix(),
                })
        }</span>
        <span class="cov0" title="0">return &amp;pb.ListCommentsResponse{
                Comments:   protoComments,
                TotalCount: int32(len(comments)),
        }, nil</span>
}

func (s *ForumServer) UpdatePost(ctx context.Context, req *pb.UpdatePostRequest) (*pb.PostResponse, error) <span class="cov0" title="0">{
        if req.PostId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор поста обязателен")
        }</span>

        <span class="cov0" title="0">post := &amp;entities.Post{
                ID: req.PostId,
        }

        if req.Title != nil </span><span class="cov0" title="0">{
                post.Title = *req.Title
        }</span>
        <span class="cov0" title="0">if req.Content != nil </span><span class="cov0" title="0">{
                post.Content = *req.Content
        }</span>

        <span class="cov0" title="0">err := s.postUC.UpdatePost(ctx, post)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось обновить пост")
        }</span>

        <span class="cov0" title="0">updatedPost, err := s.postUC.GetPostByID(ctx, req.PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить обновлённый пост")
        }</span>

        <span class="cov0" title="0">return &amp;pb.PostResponse{
                Post: &amp;pb.Post{
                        Id:             updatedPost.ID,
                        Title:          updatedPost.Title,
                        Content:        updatedPost.Content,
                        AuthorId:       updatedPost.AuthorID,
                        AuthorUsername: updatedPost.AuthorName,
                        CreatedAt:      updatedPost.CreatedAt.Unix(),
                        CommentCount:   updatedPost.CommentCount,
                },
        }, nil</span>
}

func (s *ForumServer) DeletePost(ctx context.Context, req *pb.DeletePostRequest) (*pb.EmptyMessage, error) <span class="cov0" title="0">{
        if req.PostId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор поста обязателен")
        }</span>
        <span class="cov0" title="0">err := s.postUC.DeletePost(ctx, req.PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось удалить пост")
        }</span>
        <span class="cov0" title="0">return &amp;pb.EmptyMessage{}, nil</span>
}

func (s *ForumServer) Posts(ctx context.Context, req *pb.ListPostsRequest) (*pb.ListPostsResponse, error) <span class="cov0" title="0">{
        posts, err := s.postUC.Posts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить список постов")
        }</span>

        <span class="cov0" title="0">pbPosts := make([]*pb.Post, len(posts))
        for i, post := range posts </span><span class="cov0" title="0">{
                pbPosts[i] = &amp;pb.Post{
                        Id:             post.ID,
                        Title:          post.Title,
                        Content:        post.Content,
                        AuthorId:       post.AuthorID,
                        AuthorUsername: post.AuthorName,
                        CreatedAt:      post.CreatedAt.Unix(),
                        CommentCount:   post.CommentCount,
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListPostsResponse{
                Posts: pbPosts,
        }, nil</span>
}

// Comment operations
func (s *ForumServer) CreateComment(ctx context.Context, req *pb.CreateCommentRequest) (*pb.CommentResponse, error) <span class="cov0" title="0">{
        if req.Content == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "содержание комментария обязательно")
        }</span>

        <span class="cov0" title="0">comment := &amp;entities.Comment{
                Content:    req.Content,
                AuthorID:   req.AuthorId,
                PostID:     req.PostId,
                AuthorName: req.AuthorUsername,
        }

        err := s.commentUC.CreateComment(ctx, comment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось создать комментарий")
        }</span>

        <span class="cov0" title="0">return &amp;pb.CommentResponse{
                Comment: &amp;pb.Comment{
                        Id:             comment.ID,
                        Content:        comment.Content,
                        AuthorId:       comment.AuthorID,
                        AuthorUsername: comment.AuthorName,
                        PostId:         comment.PostID,
                        CreatedAt:      comment.CreatedAt.Unix(),
                },
        }, nil</span>
}

func (s *ForumServer) GetCommentByID(ctx context.Context, req *pb.GetCommentRequest) (*pb.CommentResponse, error) <span class="cov0" title="0">{
        if req.CommentId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор комментария обязателен")
        }</span>
        <span class="cov0" title="0">comment, err := s.commentUC.GetCommentByID(ctx, req.CommentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить комментарий")
        }</span>
        <span class="cov0" title="0">return &amp;pb.CommentResponse{
                Comment: &amp;pb.Comment{
                        Id:             comment.ID,
                        Content:        comment.Content,
                        AuthorId:       comment.AuthorID,
                        AuthorUsername: comment.AuthorName,
                        PostId:         comment.PostID,
                        CreatedAt:      comment.CreatedAt.Unix(),
                },
        }, nil</span>
}

func (s *ForumServer) Comments(ctx context.Context, req *pb.ListCommentsRequest) (*pb.ListCommentsResponse, error) <span class="cov0" title="0">{
        if req.PostId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор поста обязателен")
        }</span>

        <span class="cov0" title="0">comments, err := s.commentUC.GetByPostID(ctx, req.PostId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить комментарии")
        }</span>

        <span class="cov0" title="0">pbComments := make([]*pb.Comment, len(comments))
        for i, comment := range comments </span><span class="cov0" title="0">{
                pbComments[i] = &amp;pb.Comment{
                        Id:             comment.ID,
                        Content:        comment.Content,
                        AuthorId:       comment.AuthorID,
                        AuthorUsername: comment.AuthorName,
                        PostId:         comment.PostID,
                        CreatedAt:      comment.CreatedAt.Unix(),
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListCommentsResponse{
                Comments: pbComments,
        }, nil</span>
}

func (s *ForumServer) UpdateComment(ctx context.Context, req *pb.UpdateCommentRequest) (*pb.CommentResponse, error) <span class="cov0" title="0">{
        if req.CommentId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор комментария обязателен")
        }</span>

        <span class="cov0" title="0">comment := &amp;entities.Comment{
                ID:      req.CommentId,
                Content: req.GetContent(),
        }

        err := s.commentUC.UpdateComment(ctx, comment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось обновить комментарий")
        }</span>

        <span class="cov0" title="0">return &amp;pb.CommentResponse{
                Comment: &amp;pb.Comment{
                        Id:             comment.ID,
                        Content:        comment.Content,
                        AuthorId:       comment.AuthorID,
                        AuthorUsername: comment.AuthorName,
                        PostId:         comment.PostID,
                        CreatedAt:      comment.CreatedAt.Unix(),
                },
        }, nil</span>
}

func (s *ForumServer) DeleteComment(ctx context.Context, req *pb.DeleteCommentRequest) (*pb.EmptyMessage, error) <span class="cov0" title="0">{
        fmt.Sprintln("YA TUT")
        if req.CommentId == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "идентификатор комментария и пользователя обязательны")
        }</span>

        <span class="cov0" title="0">err := s.commentUC.DeleteComment(ctx, req.CommentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось удалить комментарий")
        }</span>

        <span class="cov0" title="0">return &amp;pb.EmptyMessage{}, nil</span>
}

// Chat operations
func (s *ForumServer) SendMessage(ctx context.Context, req *pb.ChatMessage) (*pb.EmptyMessage, error) <span class="cov0" title="0">{
        if req.Content == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "содержание сообщения обязательно")
        }</span>

        <span class="cov0" title="0">msg := &amp;entities.ChatMessage{
                UserID:    req.UserId,
                Content:   req.Content,
                CreatedAt: time.Now(),
        }

        err := s.chatUC.SendMessage(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось отправить сообщение")
        }</span>

        <span class="cov0" title="0">return &amp;pb.EmptyMessage{}, nil</span>
}

func (s *ForumServer) GetMessages(ctx context.Context, req *pb.GetMessagesRequest) (*pb.GetMessagesResponse, error) <span class="cov0" title="0">{
        messages, err := s.chatUC.GetMessages(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "не удалось получить сообщения")
        }</span>

        <span class="cov0" title="0">pbMessages := make([]*pb.ChatMessage, len(messages))
        for i, msg := range messages </span><span class="cov0" title="0">{
                pbMessages[i] = &amp;pb.ChatMessage{
                        UserId:    msg.UserID,
                        Content:   msg.Content,
                        CreatedAt: msg.CreatedAt.Unix(),
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetMessagesResponse{
                Messages: pbMessages,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "net/http"
        "strconv"

        "github.com/netabakovv/forum/back/forum_service/internal/entities"
        "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/logger"

        "github.com/gin-gonic/gin"
)

type HandlerInterface interface {
        SendMessage(c *gin.Context)
        GetMessages(c *gin.Context)
}

type Handler struct {
        chatUC    usecase.ChatUsecaseInterface
        postUC    usecase.PostUsecase
        commentUC usecase.CommentUsecaseInterface
        log       logger.Logger
}

func NewHandler(chatUC usecase.ChatUsecaseInterface, postUC usecase.PostUsecase, commentUC usecase.CommentUsecaseInterface, log logger.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                chatUC:    chatUC,
                postUC:    postUC,
                commentUC: commentUC,
                log:       log,
        }
}</span>

func (h *Handler) SendMessage(c *gin.Context) <span class="cov0" title="0">{
        var msg entities.ChatMessage
        if err := c.ShouldBindJSON(&amp;msg); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.chatUC.SendMessage(c.Request.Context(), &amp;msg); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusCreated)</span>
}

func (h *Handler) GetMessages(c *gin.Context) <span class="cov0" title="0">{
        messages, err := h.chatUC.GetMessages(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, messages)</span>
}

func (h *Handler) CreatePost(c *gin.Context) <span class="cov0" title="0">{
        var post entities.Post
        if err := c.ShouldBindJSON(&amp;post); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.postUC.CreatePost(c.Request.Context(), &amp;post); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusCreated)</span>
}

func (h *Handler) GetPostByID(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        post, err := h.postUC.GetPostByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, post)</span>
}

func (h *Handler) GetAllPosts(c *gin.Context) <span class="cov0" title="0">{
        posts, err := h.postUC.Posts(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, posts)</span>
}

func (h *Handler) UpdatePost(c *gin.Context) <span class="cov0" title="0">{
        var post entities.Post
        if err := c.ShouldBindJSON(&amp;post); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        post.ID = id

        if err := h.postUC.UpdatePost(c.Request.Context(), &amp;post); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (h *Handler) DeletePost(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        if err := h.postUC.DeletePost(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (h *Handler) CreateComment(c *gin.Context) <span class="cov0" title="0">{
        var comment entities.Comment
        if err := c.ShouldBindJSON(&amp;comment); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.commentUC.CreateComment(c.Request.Context(), &amp;comment); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusCreated)</span>
}

func (h *Handler) GetCommentByID(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        comment, err := h.commentUC.GetCommentByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, comment)</span>
}

func (h *Handler) GetCommentsByPostID(c *gin.Context) <span class="cov0" title="0">{
        postID, _ := strconv.ParseInt(c.Param("post_id"), 10, 64)
        comments, err := h.commentUC.GetByPostID(c.Request.Context(), postID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, comments)</span>
}

func (h *Handler) GetCommentsByUserID(c *gin.Context) <span class="cov0" title="0">{
        userID, _ := strconv.ParseInt(c.Param("user_id"), 10, 64)
        comments, err := h.commentUC.GetByUserID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, comments)</span>
}

func (h *Handler) UpdateComment(c *gin.Context) <span class="cov0" title="0">{
        var comment entities.Comment
        if err := c.ShouldBindJSON(&amp;comment); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        comment.ID = id

        if err := h.commentUC.UpdateComment(c.Request.Context(), &amp;comment); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (h *Handler) DeleteComment(c *gin.Context) <span class="cov0" title="0">{
        id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
        if err := h.commentUC.DeleteComment(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ws

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/netabakovv/forum/back/forum_service/internal/entities"
        "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "github.com/gorilla/websocket"
)

type ChatHandler struct {
        upgrader   websocket.Upgrader
        clients    sync.Map
        chatUC     *usecase.ChatUsecase
        authClient pb.AuthServiceClient
        logger     logger.Logger
        config     *pb.ChatConfig
}

func NewChatHandler(chatUC *usecase.ChatUsecase, logger logger.Logger, config *pb.ChatConfig, authClient pb.AuthServiceClient) *ChatHandler <span class="cov0" title="0">{
        return &amp;ChatHandler{
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true
                        }</span>,
                },
                clients:    sync.Map{},
                chatUC:     chatUC,
                logger:     logger,
                config:     config,
                authClient: authClient,
        }
}

func (h *ChatHandler) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        upgrader := websocket.Upgrader{
                CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                        return true // Разрешить подключение с любого origin (на проде — поаккуратнее)
                }</span>,
        }

        <span class="cov0" title="0">conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("не удалось апгрейдить соединение", logger.NewField("error", err))
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Ожидаем первое сообщение: авторизация
        _, authMsg, err := conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("ошибка чтения авторизационного сообщения", logger.NewField("error", err))
                return
        }</span>

        <span class="cov0" title="0">var authData struct {
                Type  string `json:"type"`
                Token string `json:"token"`
        }

        if err := json.Unmarshal(authMsg, &amp;authData); err != nil || authData.Type != "auth" || authData.Token == "" </span><span class="cov0" title="0">{
                h.logger.Error("невалидное авторизационное сообщение")
                conn.WriteJSON(map[string]string{"error": "unauthorized"})
                return
        }</span>

        // Проверка токена через AuthService
        <span class="cov0" title="0">resp, err := h.authClient.ValidateToken(context.Background(), &amp;pb.ValidateRequest{
                AccessToken: authData.Token,
        })
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("невалидный токен", logger.NewField("error", err))
                conn.WriteJSON(map[string]string{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">userID := resp.UserId
        username := resp.Username

        h.logger.Info("авторизация успешна", logger.NewField("userID", userID))

        // Дальнейшая обработка: чтение/запись сообщений
        for </span><span class="cov0" title="0">{
                _, msgBytes, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Info("пользователь отключился", logger.NewField("userID", userID))
                        break</span>
                }

                <span class="cov0" title="0">var msg struct {
                        Type    string `json:"type"`
                        Content string `json:"content"`
                }

                if err := json.Unmarshal(msgBytes, &amp;msg); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if msg.Type == "message" </span><span class="cov0" title="0">{
                        chatMsg := &amp;entities.ChatMessage{
                                UserID:    userID,
                                Username:  username,
                                Content:   msg.Content,
                                CreatedAt: time.Now(),
                        }

                        if err := h.chatUC.SendMessage(context.Background(), chatMsg); err != nil </span><span class="cov0" title="0">{
                                h.logger.Error("не удалось отправить сообщение", logger.NewField("error", err))
                                continue</span>
                        }

                        // Отправляем обратно клиенту подтверждённое сообщение
                        <span class="cov0" title="0">conn.WriteJSON(chatMsg)</span>
                }
                <span class="cov0" title="0">if msg.Type == "history" </span><span class="cov0" title="0">{
                        historyMessages, err := h.chatUC.GetMessages(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Error("не удалось получить историю сообщений", logger.NewField("error", err))
                                continue</span>
                        }

                        // Отправим массив сообщений клиенту в формате:
                        <span class="cov0" title="0">resp := struct {
                                Type     string                  `json:"type"`
                                Messages []*entities.ChatMessage `json:"messages"`
                        }{
                                Type:     "history",
                                Messages: historyMessages,
                        }

                        conn.WriteJSON(resp)</span>
                }
        }

}

func (h *ChatHandler) handleMessage(msg *entities.ChatMessage) error <span class="cov0" title="0">{
        if msg.Content == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("пустое сообщение")
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        if err := h.chatUC.SendMessage(ctx, msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.broadcast(msg)
        return nil</span>
}

func (h *ChatHandler) broadcast(msg *entities.ChatMessage) <span class="cov0" title="0">{
        h.clients.Range(func(key, _ interface{}) bool </span><span class="cov0" title="0">{
                client := key.(*websocket.Conn)
                if err := client.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                        client.Close()
                        h.clients.Delete(client)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/netabakovv/forum/back/forum_service/internal/entities"
        e "github.com/netabakovv/forum/back/pkg/errors"
        "github.com/netabakovv/forum/back/pkg/logger"
)

const (
        DefaultMessagesLimit = 100
        DefaultPostsLimit    = 20
)

const (
        TargetTypePost    = "post"
        TargetTypeComment = "comment"
)

type ChatRepository interface {
        SaveMessage(ctx context.Context, userID int64, username, content string) error
        DeleteOldMessages(ctx context.Context, before time.Time) error
        GetMessages(ctx context.Context) ([]*entities.ChatMessage, error)
}

type PostRepository interface {
        CreatePost(ctx context.Context, post *entities.Post) error
        GetPostByID(ctx context.Context, id int64) (*entities.Post, error)
        UpdatePost(ctx context.Context, post *entities.Post) error
        DeletePost(ctx context.Context, id int64) error
        Posts(ctx context.Context) ([]*entities.Post, error)
}

type CommentRepository interface {
        CreateComment(ctx context.Context, comment *entities.Comment) error
        GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error)
        GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error)
        GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error)
        UpdateComment(ctx context.Context, comment *entities.Comment) error
        DeleteComment(ctx context.Context, id int64) error
}

type Db struct {
        db     *sql.DB
        logger logger.Logger
}

func NewPostRepository(db *sql.DB, log logger.Logger) PostRepository <span class="cov0" title="0">{
        return &amp;Db{db: db, logger: log}
}</span>

func NewCommentRepository(db *sql.DB, log logger.Logger) CommentRepository <span class="cov0" title="0">{
        return &amp;Db{db: db, logger: log}
}</span>

func NewChatRepository(db *sql.DB, log logger.Logger) ChatRepository <span class="cov0" title="0">{
        return &amp;Db{db: db, logger: log}
}</span>

// --- Post Repository ---

func (r *Db) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov0" title="0">{
        query := `
                INSERT INTO posts (title, content, author_id, username, created_at)
                VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
                RETURNING id, created_at`
        err := r.db.QueryRowContext(ctx, query, post.Title, post.Content, post.AuthorID, post.AuthorName).
                Scan(&amp;post.ID, &amp;post.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("создание поста: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Db) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, content, author_id, username, created_at, updated_at,
                        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
                FROM posts p WHERE id = $1`

        post := &amp;entities.Post{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;post.ID, &amp;post.Title, &amp;post.Content, &amp;post.AuthorID,
                &amp;post.AuthorName,
                &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.CommentCount,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("получение поста: %w", err)
        }</span>
        <span class="cov0" title="0">return post, nil</span>
}

func (r *Db) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov0" title="0">{
        query := `UPDATE posts SET title = $1, content = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3`
        _, err := r.db.ExecContext(ctx, query, post.Title, post.Content, post.ID)
        return err
}</span>

func (r *Db) DeletePost(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM posts WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>

func (r *Db) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, content, author_id, username, created_at, updated_at,
                        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
                FROM posts p ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("получение постов: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var posts []*entities.Post
        for rows.Next() </span><span class="cov0" title="0">{
                post := &amp;entities.Post{}
                err := rows.Scan(
                        &amp;post.ID, &amp;post.Title, &amp;post.Content, &amp;post.AuthorID,
                        &amp;post.AuthorName,
                        &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.CommentCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка сканирования поста: %w", err)
                }</span>
                <span class="cov0" title="0">posts = append(posts, post)</span>
        }
        <span class="cov0" title="0">return posts, nil</span>
}

// --- Chat Repository ---

func (r *Db) SaveMessage(ctx context.Context, userID int64, username, content string) error <span class="cov0" title="0">{
        var id int64
        query := `INSERT INTO chat_messages (user_id, username, content, created_at) VALUES ($1, $2, $3, NOW()) RETURNING id`
        return r.db.QueryRowContext(ctx, query, userID, username, content).Scan(&amp;id)
}</span>

func (r *Db) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov0" title="0">{
        query := `DELETE FROM chat_messages WHERE created_at &lt; $1`

        result, err := r.db.ExecContext(ctx, query, before)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("ошибка удаления старых сообщений", logger.NewField("error", err))
                return err
        }</span>

        <span class="cov0" title="0">affected, _ := result.RowsAffected()
        r.logger.Info("удалены старые сообщения",
                logger.NewField("count", affected),
                logger.NewField("older_than", before))

        return nil</span>
}

func (r *Db) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov0" title="0">{
        query := `
                SELECT cm.id, cm.user_id, cm.username, cm.content, cm.created_at
                FROM chat_messages cm
                ORDER BY cm.created_at
                `
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка получения сообщений: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []*entities.ChatMessage
        for rows.Next() </span><span class="cov0" title="0">{
                msg := &amp;entities.ChatMessage{}
                err := rows.Scan(&amp;msg.ID, &amp;msg.UserID, &amp;msg.Username, &amp;msg.Content, &amp;msg.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка сканирования сообщения: %w", err)
                }</span>
                <span class="cov0" title="0">messages = append(messages, msg)</span>
        }
        <span class="cov0" title="0">return messages, nil</span>
}

// ----------------------- CommentRepository

func (r *Db) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        query := `
        INSERT INTO comments (post_id, author_id, username, content, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
    `
        now := time.Now()
        comment.CreatedAt = now
        comment.UpdatedAt = nil // new comment, no update yet

        return r.db.QueryRowContext(
                ctx,
                query,
                comment.PostID,
                comment.AuthorID,
                comment.AuthorName,
                comment.Content,
                comment.CreatedAt,
                comment.UpdatedAt,
        ).Scan(&amp;comment.ID)
}</span>

func (r *Db) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov0" title="0">{
        query := `
        SELECT id, post_id, author_id, username, content, created_at, updated_at
        FROM comments
        WHERE id = $1
    `
        row := r.db.QueryRowContext(ctx, query, id)

        var comment entities.Comment
        err := row.Scan(
                &amp;comment.ID,
                &amp;comment.PostID,
                &amp;comment.AuthorID,
                &amp;comment.AuthorName,
                &amp;comment.Content,
                &amp;comment.CreatedAt,
                &amp;comment.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, e.ErrCommentNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;comment, nil</span>
}

func (r *Db) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        query := `
        SELECT id, post_id, author_id, username, content, created_at, updated_at
        FROM comments
        WHERE post_id = $1
        ORDER BY created_at ASC
    `
        rows, err := r.db.QueryContext(ctx, query, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var comments []*entities.Comment
        for rows.Next() </span><span class="cov0" title="0">{
                var comment entities.Comment
                if err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.PostID,
                        &amp;comment.AuthorID,
                        &amp;comment.AuthorName,
                        &amp;comment.Content,
                        &amp;comment.CreatedAt,
                        &amp;comment.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">comments = append(comments, &amp;comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

func (r *Db) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        query := `
        SELECT id, post_id, author_id, username, content, created_at, updated_at
        FROM comments
        WHERE author_id = $1
        ORDER BY created_at DESC
    `
        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var comments []*entities.Comment
        for rows.Next() </span><span class="cov0" title="0">{
                var comment entities.Comment
                if err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.PostID,
                        &amp;comment.AuthorID,
                        &amp;comment.AuthorName,
                        &amp;comment.Content,
                        &amp;comment.CreatedAt,
                        &amp;comment.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">comments = append(comments, &amp;comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

func (r *Db) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        now := time.Now()
        comment.UpdatedAt = &amp;now

        query := `
        UPDATE comments
        SET content = $1, updated_at = $2
        WHERE id = $3
    `
        res, err := r.db.ExecContext(ctx, query, comment.Content, comment.UpdatedAt, comment.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no comment found with id %d", comment.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Db) DeleteComment(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM comments WHERE id = $1`
        result, err := r.db.ExecContext(ctx, query, id)
        r.logger.Info("YA TUT")
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("ошибка удаления комментария", logger.NewField("error", err))
                return err
        }</span>

        <span class="cov0" title="0">affected, _ := result.RowsAffected()
        r.logger.Info("удалены старые сообщения",
                logger.NewField("count", affected))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/repository/forum.go
//
// Generated by this command:
//
//        mockgen -source=forum_service/internal/repository/forum.go -destination=forum_service/internal/repository/mocks/repo_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "github.com/netabakovv/forum/back/forum_service/internal/entities"
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockChatRepository is a mock of ChatRepository interface.
type MockChatRepository struct {
        ctrl     *gomock.Controller
        recorder *MockChatRepositoryMockRecorder
        isgomock struct{}
}

// MockChatRepositoryMockRecorder is the mock recorder for MockChatRepository.
type MockChatRepositoryMockRecorder struct {
        mock *MockChatRepository
}

// NewMockChatRepository creates a new mock instance.
func NewMockChatRepository(ctrl *gomock.Controller) *MockChatRepository <span class="cov8" title="1">{
        mock := &amp;MockChatRepository{ctrl: ctrl}
        mock.recorder = &amp;MockChatRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatRepository) EXPECT() *MockChatRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteOldMessages mocks base method.
func (m *MockChatRepository) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteOldMessages", ctx, before)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteOldMessages indicates an expected call of DeleteOldMessages.
func (mr *MockChatRepositoryMockRecorder) DeleteOldMessages(ctx, before any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOldMessages", reflect.TypeOf((*MockChatRepository)(nil).DeleteOldMessages), ctx, before)
}</span>

// GetMessages mocks base method.
func (m *MockChatRepository) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMessages", ctx)
        ret0, _ := ret[0].([]*entities.ChatMessage)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMessages indicates an expected call of GetMessages.
func (mr *MockChatRepositoryMockRecorder) GetMessages(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessages", reflect.TypeOf((*MockChatRepository)(nil).GetMessages), ctx)
}</span>

// SaveMessage mocks base method.
func (m *MockChatRepository) SaveMessage(ctx context.Context, userID int64, username, content string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveMessage", ctx, userID, username, content)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveMessage indicates an expected call of SaveMessage.
func (mr *MockChatRepositoryMockRecorder) SaveMessage(ctx, userID, username, content any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveMessage", reflect.TypeOf((*MockChatRepository)(nil).SaveMessage), ctx, userID, username, content)
}</span>

// MockPostRepository is a mock of PostRepository interface.
type MockPostRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPostRepositoryMockRecorder
        isgomock struct{}
}

// MockPostRepositoryMockRecorder is the mock recorder for MockPostRepository.
type MockPostRepositoryMockRecorder struct {
        mock *MockPostRepository
}

// NewMockPostRepository creates a new mock instance.
func NewMockPostRepository(ctrl *gomock.Controller) *MockPostRepository <span class="cov8" title="1">{
        mock := &amp;MockPostRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPostRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostRepository) EXPECT() *MockPostRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreatePost mocks base method.
func (m *MockPostRepository) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePost", ctx, post)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreatePost indicates an expected call of CreatePost.
func (mr *MockPostRepositoryMockRecorder) CreatePost(ctx, post any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePost", reflect.TypeOf((*MockPostRepository)(nil).CreatePost), ctx, post)
}</span>

// DeletePost mocks base method.
func (m *MockPostRepository) DeletePost(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePost", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePost indicates an expected call of DeletePost.
func (mr *MockPostRepositoryMockRecorder) DeletePost(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePost", reflect.TypeOf((*MockPostRepository)(nil).DeletePost), ctx, id)
}</span>

// GetPostByID mocks base method.
func (m *MockPostRepository) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPostByID", ctx, id)
        ret0, _ := ret[0].(*entities.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPostByID indicates an expected call of GetPostByID.
func (mr *MockPostRepositoryMockRecorder) GetPostByID(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostByID", reflect.TypeOf((*MockPostRepository)(nil).GetPostByID), ctx, id)
}</span>

// Posts mocks base method.
func (m *MockPostRepository) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Posts", ctx)
        ret0, _ := ret[0].([]*entities.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Posts indicates an expected call of Posts.
func (mr *MockPostRepositoryMockRecorder) Posts(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Posts", reflect.TypeOf((*MockPostRepository)(nil).Posts), ctx)
}</span>

// UpdatePost mocks base method.
func (m *MockPostRepository) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdatePost", ctx, post)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdatePost indicates an expected call of UpdatePost.
func (mr *MockPostRepositoryMockRecorder) UpdatePost(ctx, post any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePost", reflect.TypeOf((*MockPostRepository)(nil).UpdatePost), ctx, post)
}</span>

// MockCommentRepository is a mock of CommentRepository interface.
type MockCommentRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCommentRepositoryMockRecorder
        isgomock struct{}
}

// MockCommentRepositoryMockRecorder is the mock recorder for MockCommentRepository.
type MockCommentRepositoryMockRecorder struct {
        mock *MockCommentRepository
}

// NewMockCommentRepository creates a new mock instance.
func NewMockCommentRepository(ctrl *gomock.Controller) *MockCommentRepository <span class="cov8" title="1">{
        mock := &amp;MockCommentRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCommentRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentRepository) EXPECT() *MockCommentRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateComment mocks base method.
func (m *MockCommentRepository) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateComment indicates an expected call of CreateComment.
func (mr *MockCommentRepositoryMockRecorder) CreateComment(ctx, comment any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateComment", reflect.TypeOf((*MockCommentRepository)(nil).CreateComment), ctx, comment)
}</span>

// DeleteComment mocks base method.
func (m *MockCommentRepository) DeleteComment(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteComment", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteComment indicates an expected call of DeleteComment.
func (mr *MockCommentRepositoryMockRecorder) DeleteComment(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteComment", reflect.TypeOf((*MockCommentRepository)(nil).DeleteComment), ctx, id)
}</span>

// GetByPostID mocks base method.
func (m *MockCommentRepository) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByPostID", ctx, postID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByPostID indicates an expected call of GetByPostID.
func (mr *MockCommentRepositoryMockRecorder) GetByPostID(ctx, postID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPostID", reflect.TypeOf((*MockCommentRepository)(nil).GetByPostID), ctx, postID)
}</span>

// GetByUserID mocks base method.
func (m *MockCommentRepository) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUserID", ctx, userID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUserID indicates an expected call of GetByUserID.
func (mr *MockCommentRepositoryMockRecorder) GetByUserID(ctx, userID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUserID", reflect.TypeOf((*MockCommentRepository)(nil).GetByUserID), ctx, userID)
}</span>

// GetCommentByID mocks base method.
func (m *MockCommentRepository) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCommentByID", ctx, id)
        ret0, _ := ret[0].(*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCommentByID indicates an expected call of GetCommentByID.
func (mr *MockCommentRepositoryMockRecorder) GetCommentByID(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommentByID", reflect.TypeOf((*MockCommentRepository)(nil).GetCommentByID), ctx, id)
}</span>

// UpdateComment mocks base method.
func (m *MockCommentRepository) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateComment indicates an expected call of UpdateComment.
func (mr *MockCommentRepositoryMockRecorder) UpdateComment(ctx, comment any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateComment", reflect.TypeOf((*MockCommentRepository)(nil).UpdateComment), ctx, comment)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "context"
        "time"

        "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        "github.com/netabakovv/forum/back/pkg/logger"
)

type CleanupServiceInterface interface {
        NewCleanupService(chatUC *usecase.ChatUsecase, logger logger.Logger) *CleanupService
        Start(interval, lifetime time.Duration)
        Stop()
        cleanupOldMessages(lifetime time.Duration) error
}

type CleanupService struct {
        chatUC usecase.ChatUsecaseInterface
        logger logger.Logger
        stop   chan struct{}
}

func NewCleanupService(chatUC usecase.ChatUsecaseInterface, logger logger.Logger) *CleanupService <span class="cov8" title="1">{
        return &amp;CleanupService{
                chatUC: chatUC,
                logger: logger,
                stop:   make(chan struct{}),
        }
}</span>

func (s *CleanupService) Start(interval, lifetime time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                if err := s.CleanupOldMessages(lifetime); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("cleanup failed",
                                                logger.NewField("error", err))
                                }</span>
                        case &lt;-s.stop:<span class="cov8" title="1">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *CleanupService) Stop() <span class="cov8" title="1">{
        s.stop &lt;- struct{}{}
}</span>

func (s *CleanupService) CleanupOldMessages(lifetime time.Duration) error <span class="cov8" title="1">{
        cutoff := time.Now().Add(-lifetime)
        return s.chatUC.DeleteOldMessages(context.Background(), cutoff)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/service/cleanup.go

// Package mocks is a generated GoMock package.
package mocks

import (
        service "github.com/netabakovv/forum/back/forum_service/internal/service"
        usecase "github.com/netabakovv/forum/back/forum_service/internal/usecase"
        logger "github.com/netabakovv/forum/back/pkg/logger"
        reflect "reflect"
        time "time"

        gomock "github.com/golang/mock/gomock"
)

// MockCleanupServiceInterface is a mock of CleanupServiceInterface interface.
type MockCleanupServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockCleanupServiceInterfaceMockRecorder
}

// MockCleanupServiceInterfaceMockRecorder is the mock recorder for MockCleanupServiceInterface.
type MockCleanupServiceInterfaceMockRecorder struct {
        mock *MockCleanupServiceInterface
}

// NewMockCleanupServiceInterface creates a new mock instance.
func NewMockCleanupServiceInterface(ctrl *gomock.Controller) *MockCleanupServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockCleanupServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockCleanupServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCleanupServiceInterface) EXPECT() *MockCleanupServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// NewCleanupService mocks base method.
func (m *MockCleanupServiceInterface) NewCleanupService(chatUC *usecase.ChatUsecase, logger logger.Logger) *service.CleanupService <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NewCleanupService", chatUC, logger)
        ret0, _ := ret[0].(*service.CleanupService)
        return ret0
}</span>

// NewCleanupService indicates an expected call of NewCleanupService.
func (mr *MockCleanupServiceInterfaceMockRecorder) NewCleanupService(chatUC, logger interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewCleanupService", reflect.TypeOf((*MockCleanupServiceInterface)(nil).NewCleanupService), chatUC, logger)
}</span>

// Start mocks base method.
func (m *MockCleanupServiceInterface) Start(interval, lifetime time.Duration) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Start", interval, lifetime)
}</span>

// Start indicates an expected call of Start.
func (mr *MockCleanupServiceInterfaceMockRecorder) Start(interval, lifetime interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCleanupServiceInterface)(nil).Start), interval, lifetime)
}</span>

// Stop mocks base method.
func (m *MockCleanupServiceInterface) Stop() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Stop")
}</span>

// Stop indicates an expected call of Stop.
func (mr *MockCleanupServiceInterfaceMockRecorder) Stop() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockCleanupServiceInterface)(nil).Stop))
}</span>

// cleanupOldMessages mocks base method.
func (m *MockCleanupServiceInterface) cleanupOldMessages(lifetime time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "cleanupOldMessages", lifetime)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// cleanupOldMessages indicates an expected call of cleanupOldMessages.
func (mr *MockCleanupServiceInterfaceMockRecorder) cleanupOldMessages(lifetime interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "cleanupOldMessages", reflect.TypeOf((*MockCleanupServiceInterface)(nil).cleanupOldMessages), lifetime)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package usecase

import (
        "context"
        "fmt"
        "time"

        "github.com/netabakovv/forum/back/forum_service/internal/entities"
        "github.com/netabakovv/forum/back/forum_service/internal/repository"
        "github.com/netabakovv/forum/back/pkg/errors"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"
)

type ChatUsecaseInterface interface {
        DeleteOldMessages(ctx context.Context, cutoff time.Time) error
        GetMessages(ctx context.Context) ([]*entities.ChatMessage, error)
        SendMessage(ctx context.Context, msg *entities.ChatMessage) error
}

type ChatUsecase struct {
        repo            repository.ChatRepository
        logger          logger.Logger
        maxMessageLen   int
        messageLifetime time.Duration
}

func NewChatUsecase(repo repository.ChatRepository, logger logger.Logger, config *pb.ChatConfig) *ChatUsecase <span class="cov8" title="1">{
        return &amp;ChatUsecase{
                repo:            repo,
                logger:          logger,
                maxMessageLen:   int(config.MaxMessageLength),
                messageLifetime: time.Duration(config.MessageLifetimeMinutes) * time.Minute,
        }
}</span>

func (u *ChatUsecase) SendMessage(ctx context.Context, msg *entities.ChatMessage) error <span class="cov8" title="1">{
        if len(msg.Content) &gt; u.maxMessageLen </span><span class="cov8" title="1">{
                return fmt.Errorf("сообщение слишком длинное (максимум %d символов)", u.maxMessageLen)
        }</span>
        <span class="cov8" title="1">if msg.Content == "" </span><span class="cov8" title="1">{
                return errors.ErrEmptyMessage
        }</span>

        <span class="cov8" title="1">u.logger.Info("отправка сообщения в чат",
                logger.NewField("user_id", msg.UserID),
                logger.NewField("content_len", len(msg.Content)),
        )
        return u.repo.SaveMessage(ctx, msg.UserID, msg.Username, msg.Content)</span>
}

func (u *ChatUsecase) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov8" title="1">{
        return u.repo.GetMessages(ctx)
}</span>

func (u *ChatUsecase) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov8" title="1">{
        u.logger.Info("deleting old messages",
                logger.NewField("before", before))
        return u.repo.DeleteOldMessages(ctx, before)
}</span>

type CleanupService struct {
        chatUC  ChatUsecaseInterface
        logger  logger.Logger
        ticker  *time.Ticker
        done    chan bool
        timeout time.Duration
}

func NewCleanupService(chatUC ChatUsecaseInterface, logger logger.Logger) *CleanupService <span class="cov8" title="1">{
        return &amp;CleanupService{
                chatUC:  chatUC,
                logger:  logger,
                done:    make(chan bool),
                timeout: 30 * time.Second,
        }
}</span>

func (s *CleanupService) Start(interval time.Duration, messageLifetime time.Duration) <span class="cov8" title="1">{
        s.ticker = time.NewTicker(interval)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov8" title="1">
                                if err := s.Cleanup(messageLifetime); err != nil </span><span class="cov8" title="1">{
                                        s.logger.Error("failed to cleanup messages",
                                                logger.NewField("error", err))
                                }</span>
                        case &lt;-s.done:<span class="cov8" title="1">
                                s.ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *CleanupService) Stop() <span class="cov8" title="1">{
        s.done &lt;- true
}</span>

func (s *CleanupService) Cleanup(messageLifetime time.Duration) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), s.timeout)
        defer cancel()

        cutoff := time.Now().Add(-messageLifetime)

        if err := s.chatUC.DeleteOldMessages(ctx, cutoff); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("ошибка очистки старых сообщений",
                        logger.NewField("error", err),
                        logger.NewField("cutoff", cutoff),
                )
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info("успешная очистка старых сообщений",
                logger.NewField("cutoff", cutoff),
        )
        return nil</span>
}

type PostUsecase struct {
        repo   repository.PostRepository
        logger logger.Logger
}

func NewPostUsecase(repo repository.PostRepository, logger logger.Logger) *PostUsecase <span class="cov8" title="1">{
        return &amp;PostUsecase{
                repo:   repo,
                logger: logger,
        }
}</span>

func (u *PostUsecase) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        u.logger.Info("создание нового поста",
                logger.NewField("title", post.Title),
                logger.NewField("author_id", post.AuthorID))

        return u.repo.CreatePost(ctx, post)
}</span>

func (u *PostUsecase) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov8" title="1">{
        u.logger.Info("получение поста по ID",
                logger.NewField("post_id", id))

        return u.repo.GetPostByID(ctx, id)
}</span>

func (u *PostUsecase) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        u.logger.Info("обновление поста",
                logger.NewField("post_id", post.ID))
        return u.repo.UpdatePost(ctx, post)
}</span>

func (u *PostUsecase) DeletePost(ctx context.Context, id int64) error <span class="cov8" title="1">{
        u.logger.Info("удаление поста по ID",
                logger.NewField("post_id", id))
        return u.repo.DeletePost(ctx, id)
}</span>

func (u *PostUsecase) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov8" title="1">{
        return u.repo.Posts(ctx)
}</span>

type CommentUsecaseInterface interface {
        CreateComment(ctx context.Context, comment *entities.Comment) error
        GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error)
        UpdateComment(ctx context.Context, comment *entities.Comment) error
        DeleteComment(ctx context.Context, id int64) error
        GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error)
        GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error)
}

type CommentUsecase struct {
        repo   repository.CommentRepository
        logger logger.Logger
}

func NewCommentUsecase(repo repository.CommentRepository, logger logger.Logger) *CommentUsecase <span class="cov8" title="1">{
        return &amp;CommentUsecase{
                repo:   repo,
                logger: logger,
        }
}</span>

func (u *CommentUsecase) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        u.logger.Info("создание нового комментария",
                logger.NewField("comment_id", comment.ID))
        return u.repo.CreateComment(ctx, comment)
}</span>

func (u *CommentUsecase) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментария по ID",
                logger.NewField("comment_id", id))
        return u.repo.GetCommentByID(ctx, id)
}</span>

func (u *CommentUsecase) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментариев по ID поста",
                logger.NewField("post_id", postID))
        return u.repo.GetByPostID(ctx, postID)
}</span>

func (u *CommentUsecase) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментариев по ID пользователя",
                logger.NewField("user_id", userID))
        return u.repo.GetByUserID(ctx, userID)
}</span>

func (u *CommentUsecase) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        u.logger.Info("обновление комментария",
                logger.NewField("comment_id", comment.ID))
        return u.repo.UpdateComment(ctx, comment)
}</span>

func (u *CommentUsecase) DeleteComment(ctx context.Context, commentId int64) error <span class="cov8" title="1">{
        u.logger.Info("удаление комментария",
                logger.NewField("comment_id", commentId))

        u.logger.Info("YA TUT")
        return u.repo.DeleteComment(ctx, commentId)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/usecase/forum.go
//
// Generated by this command:
//
//        mockgen -source=forum_service/internal/usecase/forum.go -destination=forum_service/internal/usecase/mocks/uc_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "github.com/netabakovv/forum/back/forum_service/internal/entities"
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockChatUsecaseInterface is a mock of ChatUsecaseInterface interface.
type MockChatUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockChatUsecaseInterfaceMockRecorder
        isgomock struct{}
}

// MockChatUsecaseInterfaceMockRecorder is the mock recorder for MockChatUsecaseInterface.
type MockChatUsecaseInterfaceMockRecorder struct {
        mock *MockChatUsecaseInterface
}

// NewMockChatUsecaseInterface creates a new mock instance.
func NewMockChatUsecaseInterface(ctrl *gomock.Controller) *MockChatUsecaseInterface <span class="cov8" title="1">{
        mock := &amp;MockChatUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockChatUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatUsecaseInterface) EXPECT() *MockChatUsecaseInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteOldMessages mocks base method.
func (m *MockChatUsecaseInterface) DeleteOldMessages(ctx context.Context, cutoff time.Time) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteOldMessages", ctx, cutoff)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteOldMessages indicates an expected call of DeleteOldMessages.
func (mr *MockChatUsecaseInterfaceMockRecorder) DeleteOldMessages(ctx, cutoff any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOldMessages", reflect.TypeOf((*MockChatUsecaseInterface)(nil).DeleteOldMessages), ctx, cutoff)
}</span>

// GetMessages mocks base method.
func (m *MockChatUsecaseInterface) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMessages", ctx)
        ret0, _ := ret[0].([]*entities.ChatMessage)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMessages indicates an expected call of GetMessages.
func (mr *MockChatUsecaseInterfaceMockRecorder) GetMessages(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessages", reflect.TypeOf((*MockChatUsecaseInterface)(nil).GetMessages), ctx)
}</span>

// SendMessage mocks base method.
func (m *MockChatUsecaseInterface) SendMessage(ctx context.Context, msg *entities.ChatMessage) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendMessage", ctx, msg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendMessage indicates an expected call of SendMessage.
func (mr *MockChatUsecaseInterfaceMockRecorder) SendMessage(ctx, msg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockChatUsecaseInterface)(nil).SendMessage), ctx, msg)
}</span>

// MockCommentUsecaseInterface is a mock of CommentUsecaseInterface interface.
type MockCommentUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockCommentUsecaseInterfaceMockRecorder
        isgomock struct{}
}

// MockCommentUsecaseInterfaceMockRecorder is the mock recorder for MockCommentUsecaseInterface.
type MockCommentUsecaseInterfaceMockRecorder struct {
        mock *MockCommentUsecaseInterface
}

// NewMockCommentUsecaseInterface creates a new mock instance.
func NewMockCommentUsecaseInterface(ctrl *gomock.Controller) *MockCommentUsecaseInterface <span class="cov0" title="0">{
        mock := &amp;MockCommentUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockCommentUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentUsecaseInterface) EXPECT() *MockCommentUsecaseInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateComment mocks base method.
func (m *MockCommentUsecaseInterface) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateComment indicates an expected call of CreateComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) CreateComment(ctx, comment any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).CreateComment), ctx, comment)
}</span>

// DeleteComment mocks base method.
func (m *MockCommentUsecaseInterface) DeleteComment(ctx context.Context, id int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteComment", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteComment indicates an expected call of DeleteComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) DeleteComment(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).DeleteComment), ctx, id)
}</span>

// GetByPostID mocks base method.
func (m *MockCommentUsecaseInterface) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByPostID", ctx, postID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByPostID indicates an expected call of GetByPostID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetByPostID(ctx, postID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPostID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetByPostID), ctx, postID)
}</span>

// GetByUserID mocks base method.
func (m *MockCommentUsecaseInterface) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUserID", ctx, userID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUserID indicates an expected call of GetByUserID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetByUserID(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUserID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetByUserID), ctx, userID)
}</span>

// GetCommentByID mocks base method.
func (m *MockCommentUsecaseInterface) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCommentByID", ctx, id)
        ret0, _ := ret[0].(*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCommentByID indicates an expected call of GetCommentByID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetCommentByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommentByID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetCommentByID), ctx, id)
}</span>

// UpdateComment mocks base method.
func (m *MockCommentUsecaseInterface) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateComment indicates an expected call of UpdateComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) UpdateComment(ctx, comment any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).UpdateComment), ctx, comment)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/chat": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "Отправить сообщение в чат",
                "parameters": [
                    {
                        "description": "Сообщение для отправки",
                        "name": "message",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.ChatMessage"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Пустой ответ",
                        "schema": {
                            "$ref": "#/definitions/back_proto.EmptyMessage"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/comments": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "Создать комментарий",
                "parameters": [
                    {
                        "description": "Данные нового комментария",
                        "name": "createCommentRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.CreateCommentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Созданный комментарий",
                        "schema": {
                            "$ref": "#/definitions/back_proto.CommentResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/comments/{id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "Удалить комментарий по ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID комментария",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Пустое сообщение",
                        "schema": {
                            "$ref": "#/definitions/gateway_internal_handler.EmptyMessage"
                        }
                    },
                    "400": {
                        "description": "Неверный ID",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Не авторизован",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/logout": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Выход из системы (Logout)",
                "parameters": [
                    {
                        "description": "Access token",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.LogoutRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешный выход",
                        "schema": {
                            "$ref": "#/definitions/back_proto.LogoutResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка выхода",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/posts": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posts"
                ],
                "summary": "Создать пост",
                "parameters": [
                    {
                        "description": "Данные нового поста",
                        "name": "СreatePostRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.CreatePostRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Созданный пост",
                        "schema": {
                            "$ref": "#/definitions/back_proto.PostResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/posts/{id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "tags": [
                    "Posts"
                ],
                "summary": "Удалить пост по ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Пустое сообщение",
                        "schema": {
                            "$ref": "#/definitions/gateway_internal_handler.EmptyMessage"
                        }
                    },
                    "400": {
                        "description": "Неверный ID",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/chat": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Chat"
                ],
                "summary": "Получить все сообщения чата",
                "responses": {
                    "200": {
                        "description": "Список сообщений чата",
                        "schema": {
                            "$ref": "#/definitions/back_proto.GetMessagesResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/comments/post/{postID}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "Получить комментарии по ID поста",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "postID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Список комментариев",
                        "schema": {
                            "$ref": "#/definitions/back_proto.ListCommentsResponse"
                        }
                    },
                    "400": {
                        "description": "Неверный ID поста",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/comments/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "Получить комментарий по ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID комментария",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Комментарий",
                        "schema": {
                            "$ref": "#/definitions/back_proto.CommentResponse"
                        }
                    },
                    "400": {
                        "description": "Неверный ID",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Логин пользователя",
                "parameters": [
                    {
                        "description": "Данные для входа",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Токены и данные пользователя",
                        "schema": {
                            "$ref": "#/definitions/back_proto.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Ошибка авторизации",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/posts": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posts"
                ],
                "summary": "Получить список постов",
                "responses": {
                    "200": {
                        "description": "Созданный пост",
                        "schema": {
                            "$ref": "#/definitions/back_proto.PostResponse"
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/posts/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Posts"
                ],
                "summary": "Получить пост по ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID поста",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Пост",
                        "schema": {
                            "$ref": "#/definitions/back_proto.PostResponse"
                        }
                    },
                    "400": {
                        "description": "Неверный ID",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/refresh": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Обновить токен",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.RefreshTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Новые токены",
                        "schema": {
                            "$ref": "#/definitions/back_proto.RefreshTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Ошибка обновления токена",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Регистрация пользователя",
                "parameters": [
                    {
                        "description": "Данные для регистрации",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/back_proto.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Токены после регистрации",
                        "schema": {
                            "$ref": "#/definitions/back_proto.RegisterResponse"
                        }
                    },
                    "400": {
                        "description": "Ошибка валидации запроса",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "back_proto.ChatMessage": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "back_proto.CommentResponse": {
            "type": "object",
            "properties": {
                "comment": {
                    "$ref": "#/definitions/proto.Comment"
                }
            }
        },
        "back_proto.CreateCommentRequest": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer"
                },
                "author_username": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "post_id": {
                    "type": "integer"
                }
            }
        },
        "back_proto.CreatePostRequest": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer"
                },
                "author_username": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "back_proto.EmptyMessage": {
            "type": "object"
        },
        "back_proto.GetMessagesResponse": {
            "type": "object",
            "properties": {
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/proto.ChatMessage"
                    }
                },
                "total_count": {
                    "type": "integer"
                }
            }
        },
        "back_proto.ListCommentsResponse": {
            "type": "object",
            "properties": {
                "comments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/proto.Comment"
                    }
                },
                "total_count": {
                    "type": "integer"
                }
            }
        },
        "back_proto.LoginRequest": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "back_proto.LoginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "expires_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "refresh_token": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/proto.UserProfileResponse"
                }
            }
        },
        "back_proto.LogoutRequest": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                }
            }
        },
        "back_proto.LogoutResponse": {
            "type": "object",
            "properties": {
                "success": {
                    "type": "boolean"
                }
            }
        },
        "back_proto.PostResponse": {
            "type": "object",
            "properties": {
                "post": {
                    "$ref": "#/definitions/proto.Post"
                }
            }
        },
        "back_proto.RefreshTokenRequest": {
            "type": "object",
            "properties": {
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "back_proto.RefreshTokenResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "expires_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "back_proto.RegisterRequest": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "back_proto.RegisterResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "expires_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "gateway_internal_handler.EmptyMessage": {
            "type": "object"
        },
        "proto.ChatMessage": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "proto.Comment": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer"
                },
                "author_username": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "post_id": {
                    "type": "integer"
                }
            }
        },
        "proto.Post": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "integer"
                },
                "author_username": {
                    "type": "string"
                },
                "comment_count": {
                    "type": "integer"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "proto.UserProfileResponse": {
            "type": "object",
            "properties": {
                "comment_count": {
                    "type": "integer"
                },
                "created_at": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "post_count": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8090",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Gateway API",
        Description:      "API для форума с авторизацией, постами и комментариями",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

// @title Gateway API
// @version 1.0
// @description API для форума с авторизацией, постами и комментариями

// @host localhost:8090
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization

import (
        "time"

        "github.com/netabakovv/forum/back/gateway/internal/delivery/http"
        "github.com/netabakovv/forum/back/gateway/internal/handler"
        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        _ "github.com/lib/pq"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        log := logger.NewStdLogger()

        authConn, err := grpc.Dial("auth_service:50053", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось подключиться к gRPC", logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">defer authConn.Close()

        forumConn, err := grpc.Dial("forum_service:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось подключиться к gRPC", logger.NewField("error", err))
        }</span>
        <span class="cov0" title="0">defer forumConn.Close()

        authClient := pb.NewAuthServiceClient(authConn)
        forumClient := pb.NewForumServiceClient(forumConn)

        //forumClient := pb.NewForumServiceClient(conn)

        // Инициализация Gin
        router := gin.Default()

        // Разрешить CORS
        router.Use(cors.New(cors.Config{
                AllowOrigins:     []string{"http://localhost:3000"}, // адрес фронта
                AllowMethods:     []string{"GET", "POST", "OPTIONS", "DELETE"},
                AllowHeaders:     []string{"Authorization", "Content-Type"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }))

        handler := handler.NewHandler(forumClient, authClient, log)
        http.RegisterRoutes(router, handler)

        // Запуск gateway
        if err := router.Run(":8090"); err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось запустить gateway", logger.NewField("error", err))
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package http

import (
        "net/http"

        pb "github.com/netabakovv/forum/back/proto"

        "github.com/gin-gonic/gin"
)

func AuthMiddleware(authClient pb.AuthServiceClient) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 1. Получаем access token из заголовка Authorization
                token := c.GetHeader("Authorization")
                if token == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "токен не найден"})
                        return
                }</span>

                // 2. Удаляем префикс "Bearer "
                <span class="cov0" title="0">if len(token) &gt; 7 &amp;&amp; token[:7] == "Bearer " </span><span class="cov0" title="0">{
                        token = token[7:]
                }</span>

                // 3. Валидируем токен через gRPC Auth-сервис
                <span class="cov0" title="0">resp, err := authClient.ValidateToken(c.Request.Context(), &amp;pb.ValidateRequest{
                        AccessToken: token,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "недействительный токен"})
                        return
                }</span>

                // 4. Сохраняем userID и username в контекст
                <span class="cov0" title="0">c.Set("userID", resp.UserId)
                c.Set("username", resp.Username)
                c.Set("isAdmin", resp.IsAdmin)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package http

import (
        "net/http"

        "github.com/netabakovv/forum/back/gateway/internal/handler"

        _ "github.com/netabakovv/forum/back/gateway/cmd/docs" // Импорт сгенерированной документации

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func RegisterRoutes(r *gin.Engine, h *handler.Handler) <span class="cov0" title="0">{
        // Группа защищенных маршрутов
        protected := r.Group("/api")
        protected.Use(AuthMiddleware(h.Auth))

        // Профиль пользователя
        protected.GET("/profile", func(c *gin.Context) </span><span class="cov0" title="0">{
                userID := c.GetString("userID")
                username := c.GetString("username")
                isAdmin := c.GetBool("is_admin")

                c.JSON(http.StatusOK, gin.H{
                        "userID":   userID,
                        "username": username,
                        "isAdmin":  isAdmin,
                })
        }</span>)

        // Аутентификация
        <span class="cov0" title="0">r.POST("/register", h.Register())
        r.POST("/login", h.Login())
        r.POST("/refresh", h.RefreshToken())
        protected.POST("/logout", h.Logout())

        // Посты
        r.GET("/posts", h.GetPosts())
        r.GET("/posts/:id", h.GetPost())
        protected.POST("/posts", h.CreatePost())
        protected.DELETE("/posts/:id", h.DeletePost())

        // Комментарии
        r.GET("/comments/:id", h.GetCommentByID())
        r.GET("/comments/post/:postID", h.GetCommentsByPostID())
        protected.POST("/comments", h.CreateComment())
        protected.DELETE("/comments/:id", h.DeleteComment())

        // Чат
        protected.POST("/chat", h.SendMessage())
        r.GET("/chat", h.GetMessages())

        // WebSocket
        r.GET("/ws/chat", func(c *gin.Context) </span><span class="cov0" title="0">{
                target := "ws://localhost:8080/ws/chat"
                http.Redirect(c.Writer, c.Request, target, http.StatusTemporaryRedirect)
        }</span>)

        // Swagger UI
        <span class="cov0" title="0">r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handler

import (
        "context"
        "fmt"
        "net/http"
        "strconv"

        "github.com/netabakovv/forum/back/pkg/logger"
        pb "github.com/netabakovv/forum/back/proto"

        "github.com/gin-gonic/gin"
)

type EmptyMessage struct{}

type Handler struct {
        Forum pb.ForumServiceClient
        Auth  pb.AuthServiceClient
        log   logger.Logger
}

func NewHandler(forumClient pb.ForumServiceClient, authClient pb.AuthServiceClient, log logger.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                Forum: forumClient,
                Auth:  authClient,
                log:   log,
        }
}</span>

// --- Auth ---

// @Summary Логин пользователя
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body pb.LoginRequest true "Данные для входа"
// @Success 200 {object} pb.LoginResponse "Токены и данные пользователя"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 401 {object} map[string]string "Ошибка авторизации"
// @Router /login [post]
func (h *Handler) Login() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        Username string `json:"username"`
                        Password string `json:"password"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">resp, err := h.Auth.Login(c, &amp;pb.LoginRequest{
                        Username: req.Username,
                        Password: req.Password,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": fmt.Sprintf("ошибка авторизации: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "access_token":  resp.AccessToken,
                        "refresh_token": resp.RefreshToken,
                        "expires_at":    resp.ExpiresAt,
                        "is_admin":      resp.User.IsAdmin,
                        "user":          resp.User,
                })</span>

        }
}

// @Summary Регистрация пользователя
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body pb.RegisterRequest true "Данные для регистрации"
// @Success 200 {object} pb.RegisterResponse "Токены после регистрации"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Внутренняя ошибка сервера"
// @Router /register [post]
func (h *Handler) Register() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        Username string `json:"username"`
                        Password string `json:"password"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">_, err := h.Auth.Register(c, &amp;pb.RegisterRequest{
                        Username: req.Username,
                        Password: req.Password,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка регистрации: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "успешно зарегистрирован"})</span>
        }
}

// @Summary Обновить токен
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body pb.RefreshTokenRequest true "Refresh token"
// @Success 200 {object} pb.RefreshTokenResponse "Новые токены"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Ошибка обновления токена"
// @Router /refresh [post]
func (h *Handler) RefreshToken() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        RefreshToken string `json:"refresh_token"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">resp, err := h.Auth.RefreshToken(c, &amp;pb.RefreshTokenRequest{
                        RefreshToken: req.RefreshToken,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка обновления токена: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "access_token":  resp.AccessToken,
                        "refresh_token": resp.RefreshToken,
                        "expires_at":    resp.ExpiresAt, // resp.ExpiresAt уже Unix-секунды из protobuf
                })</span>
        }
}

func (h *Handler) ValidateToken() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        AccessToken string `json:"access_token"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">_, err := h.Auth.ValidateToken(c, &amp;pb.ValidateRequest{
                        AccessToken: req.AccessToken,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка валидации токена: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "токен валиден"})</span>
        }
}

// @Summary Выход из системы (Logout)
// @Tags Auth
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param request body pb.LogoutRequest true "Access token"
// @Success 200 {object} pb.LogoutResponse "Успешный выход"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Ошибка выхода"
// @Router /api/logout [post]
func (h *Handler) Logout() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        AccessToken string `json:"access_token"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">_, err := h.Auth.Logout(c, &amp;pb.LogoutRequest{
                        AccessToken: req.AccessToken,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка выхода: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "выход успешен"})</span>
        }
}

func (h *Handler) CheckAdminStatus() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        UserId int64 `json:"user_id"`
                }
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">_, err := h.Auth.CheckAdminStatus(c, &amp;pb.CheckAdminRequest{
                        UserId: req.UserId,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка проверки статуса админа: %v", err)})
                        return
                }</span>
        }
}

// --- Forum ---

// @Summary Получить список постов
// @Tags Posts
// @Produce json
// @Success 200 {object} pb.PostResponse "Созданный пост"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /posts [get]
func (h *Handler) GetPosts() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                resp, err := h.Forum.Posts(c, &amp;pb.ListPostsRequest{})

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("не удалось получить посты: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp.Posts)</span>
        }
}

// @Summary Создать пост
// @Tags Posts
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param СreatePostRequest body pb.CreatePostRequest true "Данные нового поста"
// @Success 200 {object} pb.PostResponse "Созданный пост"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /api/posts [post]
func (h *Handler) CreatePost() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.CreatePostRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">userID, _ := c.Get("userID")
                req.AuthorId = userID.(int64)

                resp, err := h.Forum.CreatePost(context.Background(), &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("не удалось создать пост: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

// @Summary Получить пост по ID
// @Tags Posts
// @Produce json
// @Param id path int true "ID поста"
// @Success 200 {object} pb.PostResponse "Пост"
// @Failure 400 {object} map[string]string "Неверный ID"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /posts/{id} [get]
func (h *Handler) GetPost() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                idStr := c.Param("id")
                postID, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "неверный ID поста"})
                        return
                }</span>

                <span class="cov0" title="0">req := &amp;pb.GetPostRequest{PostId: postID}
                resp, err := h.Forum.GetPost(c, req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка получения поста: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

func (h *Handler) UpdatePost() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.UpdatePostRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">resp, err := h.Forum.UpdatePost(c, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка обновления поста: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

// @Summary Удалить пост по ID
// @Tags Posts
// @Security ApiKeyAuth
// @Param id path int true "ID поста"
// @Success 200 {object} pb.EmptyMessage "Пустое сообщение"
// @Failure 400 {object} map[string]string "Неверный ID"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /api/posts/{id} [delete]
func (h *Handler) DeletePost() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                postIDStr := c.Param("id")
                postID, err := strconv.ParseInt(postIDStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный id поста: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">req := &amp;pb.DeletePostRequest{
                        PostId: postID,
                }

                _, err = h.Forum.DeletePost(c, req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка удаления поста: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "пост удален"})</span>
        }
}

// --- Comment operations ---

// @Summary Создать комментарий
// @Tags Comments
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param createCommentRequest body pb.CreateCommentRequest true "Данные нового комментария"
// @Success 200 {object} pb.CommentResponse "Созданный комментарий"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /api/comments [post]
func (h *Handler) CreateComment() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.CreateCommentRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">userID, _ := c.Get("userID")
                req.AuthorId = userID.(int64)

                resp, err := h.Forum.CreateComment(context.Background(), &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("не удалось создать комментарий: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

// @Summary Получить комментарий по ID
// @Tags Comments
// @Produce json
// @Param id path int true "ID комментария"
// @Success 200 {object} pb.CommentResponse "Комментарий"
// @Failure 400 {object} map[string]string "Неверный ID"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /comments/{id} [get]
func (h *Handler) GetCommentByID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                idStr := c.Param("id")
                commentID, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "неверный ID комментария"})
                        return
                }</span>

                <span class="cov0" title="0">req := &amp;pb.GetCommentRequest{CommentId: commentID}
                resp, err := h.Forum.GetCommentByID(c, req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка получения комментария: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

// @Summary Получить комментарии по ID поста
// @Tags Comments
// @Produce json
// @Param postID path int true "ID поста"
// @Success 200 {object} pb.ListCommentsResponse "Список комментариев"
// @Failure 400 {object} map[string]string "Неверный ID поста"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /comments/post/{postID} [get]
func (h *Handler) GetCommentsByPostID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                postIDStr := c.Param("postID")
                postID, err := strconv.ParseInt(postIDStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "неверный ID поста"})
                        return
                }</span>

                <span class="cov0" title="0">req := &amp;pb.GetCommentsByPostIDRequest{PostId: postID}
                resp, err := h.Forum.GetByPostID(c, req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка получения комментариев: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, resp.Comments)</span>
        }
}

func (h *Handler) UpdateComment() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.UpdateCommentRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">resp, err := h.Forum.UpdateComment(c, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка обновления комментария: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
        }
}

// @Summary Удалить комментарий по ID
// @Tags Comments
// @Security ApiKeyAuth
// @Param id path int true "ID комментария"
// @Success 200 {object} pb.EmptyMessage "Пустое сообщение"
// @Failure 400 {object} map[string]string "Неверный ID"
// @Failure 401 {object} map[string]string "Не авторизован"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /api/comments/{id} [delete]
func (h *Handler) DeleteComment() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                commentIDstr := c.Param("id")
                commentID, err := strconv.ParseInt(commentIDstr, 10, 64)
                if commentID == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "идентификатор комментария обязателен"})
                        return
                }</span>

                // userIDstr := c.GetString("userID")
                // userID, err := strconv.ParseInt(userIDstr, 10, 64)
                // if userID == 0 {
                //         c.JSON(http.StatusUnauthorized, gin.H{"error": "не авторизован"})
                //         return
                // }

                <span class="cov0" title="0">req := pb.DeleteCommentRequest{
                        CommentId: commentID,
                }

                _, err = h.Forum.DeleteComment(c, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка удаления комментария: %v", err)})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "комментарий удален"})</span>
        }
}

func (h *Handler) Comments() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.ListCommentsRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">resp, err := h.Forum.Comments(c, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка получения комментариев: %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp.Comments)</span>
        }
}

// --- Chat operations ---

// @Summary Отправить сообщение в чат
// @Tags Chat
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param message body pb.ChatMessage true "Сообщение для отправки"
// @Success 200 {object} pb.EmptyMessage "Пустой ответ"
// @Failure 400 {object} map[string]string "Ошибка валидации запроса"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /api/chat [post]
func (h *Handler) SendMessage() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var msg pb.ChatMessage
                if err := c.ShouldBindJSON(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("неверный формат запроса %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">_, err := h.Forum.SendMessage(c, &amp;msg)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка отправки сообщений %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "сообщение отправлено"})</span>
        }
}

// @Summary Получить все сообщения чата
// @Tags Chat
// @Produce json
// @Success 200 {object} pb.GetMessagesResponse "Список сообщений чата"
// @Failure 500 {object} map[string]string "Ошибка сервера"
// @Router /chat [get]
func (h *Handler) GetMessages() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req pb.GetMessagesRequest
                resp, err := h.Forum.GetMessages(c, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("ошибка получения сообщений %v", err)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, resp.Messages)</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package database

import (
        "fmt"

        "github.com/netabakovv/forum/back/pkg/logger"

        "github.com/golang-migrate/migrate"
)

func RunMigrations(dbURL string, log logger.Logger) error <span class="cov0" title="0">{
        m, err := migrate.New(
                "file://migrations",
                dbURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("migrations completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package logger

// Logger определяет интерфейс для логирования
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)
}

// Field представляет поле с дополнительной информацией для лога
type Field struct {
        Key   string
        Value interface{}
}

// NewField создает новое поле для лога
func NewField(key string, value interface{}) Field <span class="cov8" title="1">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/logger/interface.go

// Package mocks is a generated GoMock package.
package mocks

import (
        logger "github.com/netabakovv/forum/back/pkg/logger"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockLogger is a mock of Logger interface.
type MockLogger struct {
        ctrl     *gomock.Controller
        recorder *MockLoggerMockRecorder
}

// MockLoggerMockRecorder is the mock recorder for MockLogger.
type MockLoggerMockRecorder struct {
        mock *MockLogger
}

// NewMockLogger creates a new mock instance.
func NewMockLogger(ctrl *gomock.Controller) *MockLogger <span class="cov8" title="1">{
        mock := &amp;MockLogger{ctrl: ctrl}
        mock.recorder = &amp;MockLoggerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Debug mocks base method.
func (m *MockLogger) Debug(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{msg}
        for _, a := range fields </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Debug", varargs...)</span>
}

// Debug indicates an expected call of Debug.
func (mr *MockLoggerMockRecorder) Debug(msg interface{}, fields ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{msg}, fields...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockLogger)(nil).Debug), varargs...)
}</span>

// Error mocks base method.
func (m *MockLogger) Error(msg string, fields ...logger.Field) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{msg}
        for _, a := range fields </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Error", varargs...)</span>
}

// Error indicates an expected call of Error.
func (mr *MockLoggerMockRecorder) Error(msg interface{}, fields ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{msg}, fields...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockLogger)(nil).Error), varargs...)
}</span>

// Fatal mocks base method.
func (m *MockLogger) Fatal(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{msg}
        for _, a := range fields </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Fatal", varargs...)</span>
}

// Fatal indicates an expected call of Fatal.
func (mr *MockLoggerMockRecorder) Fatal(msg interface{}, fields ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{msg}, fields...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fatal", reflect.TypeOf((*MockLogger)(nil).Fatal), varargs...)
}</span>

// Info mocks base method.
func (m *MockLogger) Info(msg string, fields ...logger.Field) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{msg}
        for _, a := range fields </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Info", varargs...)</span>
}

// Info indicates an expected call of Info.
func (mr *MockLoggerMockRecorder) Info(msg interface{}, fields ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{msg}, fields...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockLogger)(nil).Info), varargs...)
}</span>

// Warn mocks base method.
func (m *MockLogger) Warn(msg string, fields ...logger.Field) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{msg}
        for _, a := range fields </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Warn", varargs...)</span>
}

// Warn indicates an expected call of Warn.
func (mr *MockLoggerMockRecorder) Warn(msg interface{}, fields ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{msg}, fields...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockLogger)(nil).Warn), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package logger

import (
    "fmt"
    "log"
    "os"
)

type stdLogger struct {
    debug *log.Logger
    info  *log.Logger
    warn  *log.Logger
    error *log.Logger
    fatal *log.Logger
}

// NewStdLogger создает новый логгер на основе стандартного log пакета
func NewStdLogger() Logger <span class="cov8" title="1">{
    return &amp;stdLogger{
        debug: log.New(os.Stdout, "DEBUG: ", log.Ldate|log.Ltime|log.Lshortfile),
        info:  log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile),
        warn:  log.New(os.Stdout, "WARN: ", log.Ldate|log.Ltime|log.Lshortfile),
        error: log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile),
        fatal: log.New(os.Stderr, "FATAL: ", log.Ldate|log.Ltime|log.Lshortfile),
    }
}</span>

func (l *stdLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
    l.debug.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
    l.info.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
    l.warn.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
    l.error.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
    l.fatal.Output(2, formatMsg(msg, fields...))
    os.Exit(1)
}</span>

// formatMsg форматирует сообщение с дополнительными полями
func formatMsg(msg string, fields ...Field) string <span class="cov8" title="1">{
    if len(fields) == 0 </span><span class="cov8" title="1">{
        return msg
    }</span>
    
    <span class="cov8" title="1">result := msg + " {"
    for i, f := range fields </span><span class="cov8" title="1">{
        if i &gt; 0 </span><span class="cov8" title="1">{
            result += ", "
        }</span>
        <span class="cov8" title="1">result += fmt.Sprintf("%s: %v", f.Key, f.Value)</span>
    }
    <span class="cov8" title="1">result += "}"
    return result</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.30.2
// source: proto/forum.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ================== Error Handling ==================
type ErrorCode int32

const (
        ErrorCode_ERROR_UNSPECIFIED         ErrorCode = 0
        ErrorCode_ERROR_INVALID_CREDENTIALS ErrorCode = 1
        ErrorCode_ERROR_USER_NOT_FOUND      ErrorCode = 2
        ErrorCode_ERROR_USER_ALREADY_EXISTS ErrorCode = 3
        ErrorCode_ERROR_TOKEN_EXPIRED       ErrorCode = 4
        ErrorCode_ERROR_PERMISSION_DENIED   ErrorCode = 5
)

// Enum value maps for ErrorCode.
var (
        ErrorCode_name = map[int32]string{
                0: "ERROR_UNSPECIFIED",
                1: "ERROR_INVALID_CREDENTIALS",
                2: "ERROR_USER_NOT_FOUND",
                3: "ERROR_USER_ALREADY_EXISTS",
                4: "ERROR_TOKEN_EXPIRED",
                5: "ERROR_PERMISSION_DENIED",
        }
        ErrorCode_value = map[string]int32{
                "ERROR_UNSPECIFIED":         0,
                "ERROR_INVALID_CREDENTIALS": 1,
                "ERROR_USER_NOT_FOUND":      2,
                "ERROR_USER_ALREADY_EXISTS": 3,
                "ERROR_TOKEN_EXPIRED":       4,
                "ERROR_PERMISSION_DENIED":   5,
        }
)

func (x ErrorCode) Enum() *ErrorCode <span class="cov0" title="0">{
        p := new(ErrorCode)
        *p = x
        return p
}</span>

func (x ErrorCode) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_forum_proto_enumTypes[0].Descriptor()
}</span>

func (ErrorCode) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_forum_proto_enumTypes[0]
}</span>

func (x ErrorCode) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{0}
}</span>

// Определяем собственное пустое сообщение
type EmptyMessage struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EmptyMessage) Reset() <span class="cov0" title="0">{
        *x = EmptyMessage{}
        mi := &amp;file_proto_forum_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EmptyMessage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EmptyMessage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EmptyMessage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EmptyMessage.ProtoReflect.Descriptor instead.
func (*EmptyMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{0}
}</span>

type RegisterRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RegisterResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp
        User          *UserProfileResponse   `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{4}
}</span>

func (x *LoginResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetUser() *UserProfileResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RefreshTokenRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshToken  string                 `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshTokenRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{5}
}</span>

func (x *RefreshTokenRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshTokenResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshTokenResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{6}
}</span>

func (x *RefreshTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ValidateRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ValidateRequest) Reset() <span class="cov0" title="0">{
        *x = ValidateRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateRequest.ProtoReflect.Descriptor instead.
func (*ValidateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ValidateRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ValidateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        IsValid       bool                   `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
        UserId        int64                  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username      string                 `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
        IsAdmin       bool                   `protobuf:"varint,4,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ValidateResponse) Reset() <span class="cov0" title="0">{
        *x = ValidateResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateResponse.ProtoReflect.Descriptor instead.
func (*ValidateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{8}
}</span>

func (x *ValidateResponse) GetIsValid() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsValid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ValidateResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ValidateResponse) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidateResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{9}
}</span>

func (x *LogoutRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{10}
}</span>

func (x *LogoutResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ================== Post Service ==================
type Post struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Title          string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        Content        string                 `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64                  `protobuf:"varint,4,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        AuthorUsername string                 `protobuf:"bytes,5,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        CreatedAt      int64                  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        CommentCount   int32                  `protobuf:"varint,7,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *Post) Reset() <span class="cov0" title="0">{
        *x = Post{}
        mi := &amp;file_proto_forum_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Post) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Post) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Post) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Post.ProtoReflect.Descriptor instead.
func (*Post) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{11}
}</span>

func (x *Post) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetCommentCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Post          *Post                  `protobuf:"bytes,1,opt,name=post,proto3" json:"post,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PostResponse) Reset() <span class="cov0" title="0">{
        *x = PostResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PostResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PostResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PostResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PostResponse.ProtoReflect.Descriptor instead.
func (*PostResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{12}
}</span>

func (x *PostResponse) GetPost() *Post <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Post
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreatePostRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Title          string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        Content        string                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64                  `protobuf:"varint,3,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        AuthorUsername string                 `protobuf:"bytes,4,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *CreatePostRequest) Reset() <span class="cov0" title="0">{
        *x = CreatePostRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreatePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreatePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreatePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreatePostRequest.ProtoReflect.Descriptor instead.
func (*CreatePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{13}
}</span>

func (x *CreatePostRequest) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreatePostRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreatePostRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreatePostRequest) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetPostRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PostId        int64                  `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPostRequest) Reset() <span class="cov0" title="0">{
        *x = GetPostRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPostRequest.ProtoReflect.Descriptor instead.
func (*GetPostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetPostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdatePostRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PostId        int64                  `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        Title         *string                `protobuf:"bytes,2,opt,name=title,proto3,oneof" json:"title,omitempty"`
        Content       *string                `protobuf:"bytes,3,opt,name=content,proto3,oneof" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdatePostRequest) Reset() <span class="cov0" title="0">{
        *x = UpdatePostRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdatePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdatePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdatePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdatePostRequest.ProtoReflect.Descriptor instead.
func (*UpdatePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{15}
}</span>

func (x *UpdatePostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdatePostRequest) GetTitle() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Title != nil </span><span class="cov0" title="0">{
                return *x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdatePostRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Content != nil </span><span class="cov0" title="0">{
                return *x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeletePostRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PostId        int64                  `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeletePostRequest) Reset() <span class="cov0" title="0">{
        *x = DeletePostRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeletePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeletePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeletePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeletePostRequest.ProtoReflect.Descriptor instead.
func (*DeletePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{16}
}</span>

func (x *DeletePostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListPostsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AuthorId      *int64                 `protobuf:"varint,1,opt,name=author_id,json=authorId,proto3,oneof" json:"author_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListPostsRequest) Reset() <span class="cov0" title="0">{
        *x = ListPostsRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListPostsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListPostsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListPostsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListPostsRequest.ProtoReflect.Descriptor instead.
func (*ListPostsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{17}
}</span>

func (x *ListPostsRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.AuthorId != nil </span><span class="cov0" title="0">{
                return *x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListPostsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Posts         []*Post                `protobuf:"bytes,1,rep,name=posts,proto3" json:"posts,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListPostsResponse) Reset() <span class="cov0" title="0">{
        *x = ListPostsResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListPostsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListPostsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListPostsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListPostsResponse.ProtoReflect.Descriptor instead.
func (*ListPostsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{18}
}</span>

func (x *ListPostsResponse) GetPosts() []*Post <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Posts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListPostsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ================== Comment Service ==================
type Comment struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Content        string                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64                  `protobuf:"varint,3,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        AuthorUsername string                 `protobuf:"bytes,4,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        PostId         int64                  `protobuf:"varint,5,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        CreatedAt      int64                  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *Comment) Reset() <span class="cov0" title="0">{
        *x = Comment{}
        mi := &amp;file_proto_forum_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Comment) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Comment) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Comment) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Comment.ProtoReflect.Descriptor instead.
func (*Comment) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{19}
}</span>

func (x *Comment) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Comment) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Comment) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CommentResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Comment       *Comment               `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CommentResponse) Reset() <span class="cov0" title="0">{
        *x = CommentResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CommentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommentResponse.ProtoReflect.Descriptor instead.
func (*CommentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{20}
}</span>

func (x *CommentResponse) GetComment() *Comment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comment
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateCommentRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Content        string                 `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64                  `protobuf:"varint,2,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        PostId         int64                  `protobuf:"varint,3,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        AuthorUsername string                 `protobuf:"bytes,4,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *CreateCommentRequest) Reset() <span class="cov0" title="0">{
        *x = CreateCommentRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{21}
}</span>

func (x *CreateCommentRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateCommentRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateCommentRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateCommentRequest) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetCommentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CommentId     int64                  `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetCommentRequest) Reset() <span class="cov0" title="0">{
        *x = GetCommentRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCommentRequest.ProtoReflect.Descriptor instead.
func (*GetCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{22}
}</span>

func (x *GetCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetCommentsByPostIDRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PostId        int64                  `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetCommentsByPostIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetCommentsByPostIDRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetCommentsByPostIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCommentsByPostIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCommentsByPostIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCommentsByPostIDRequest.ProtoReflect.Descriptor instead.
func (*GetCommentsByPostIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{23}
}</span>

func (x *GetCommentsByPostIDRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListCommentsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PostId        int64                  `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsRequest) Reset() <span class="cov0" title="0">{
        *x = ListCommentsRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListCommentsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCommentsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCommentsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListCommentsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{24}
}</span>

func (x *ListCommentsRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListCommentsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Comments      []*Comment             `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsResponse) Reset() <span class="cov0" title="0">{
        *x = ListCommentsResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListCommentsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCommentsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCommentsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListCommentsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{25}
}</span>

func (x *ListCommentsResponse) GetComments() []*Comment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListCommentsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateCommentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CommentId     int64                  `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
        Content       *string                `protobuf:"bytes,2,opt,name=content,proto3,oneof" json:"content,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateCommentRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateCommentRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateCommentRequest.ProtoReflect.Descriptor instead.
func (*UpdateCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{26}
}</span>

func (x *UpdateCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateCommentRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Content != nil </span><span class="cov0" title="0">{
                return *x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteCommentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        CommentId     int64                  `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteCommentRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteCommentRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteCommentRequest.ProtoReflect.Descriptor instead.
func (*DeleteCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{27}
}</span>

func (x *DeleteCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ================== Chat Service ==================
type ChatMessage struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        int64                  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Content       string                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ChatMessage) Reset() <span class="cov0" title="0">{
        *x = ChatMessage{}
        mi := &amp;file_proto_forum_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ChatMessage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChatMessage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChatMessage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[28]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChatMessage.ProtoReflect.Descriptor instead.
func (*ChatMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{28}
}</span>

func (x *ChatMessage) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatMessage) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ChatMessage) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetMessagesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMessagesRequest) Reset() <span class="cov0" title="0">{
        *x = GetMessagesRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMessagesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMessagesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMessagesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMessagesRequest.ProtoReflect.Descriptor instead.
func (*GetMessagesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{29}
}</span>

type GetMessagesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Messages      []*ChatMessage         `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMessagesResponse) Reset() <span class="cov0" title="0">{
        *x = GetMessagesResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMessagesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMessagesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMessagesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMessagesResponse.ProtoReflect.Descriptor instead.
func (*GetMessagesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{30}
}</span>

func (x *GetMessagesResponse) GetMessages() []*ChatMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Messages
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMessagesResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ChatConfig struct {
        state                  protoimpl.MessageState `protogen:"open.v1"`
        MessageLifetimeMinutes int32                  `protobuf:"varint,1,opt,name=message_lifetime_minutes,json=messageLifetimeMinutes,proto3" json:"message_lifetime_minutes,omitempty"` // Время жизни сообщений
        MaxMessageLength       int32                  `protobuf:"varint,2,opt,name=max_message_length,json=maxMessageLength,proto3" json:"max_message_length,omitempty"`                   // Максимальная длина сообщения
        OnlyAuthenticated      bool                   `protobuf:"varint,3,opt,name=only_authenticated,json=onlyAuthenticated,proto3" json:"only_authenticated,omitempty"`                  // Только для авторизованных
        unknownFields          protoimpl.UnknownFields
        sizeCache              protoimpl.SizeCache
}

func (x *ChatConfig) Reset() <span class="cov0" title="0">{
        *x = ChatConfig{}
        mi := &amp;file_proto_forum_proto_msgTypes[31]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ChatConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChatConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChatConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[31]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChatConfig.ProtoReflect.Descriptor instead.
func (*ChatConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{31}
}</span>

func (x *ChatConfig) GetMessageLifetimeMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageLifetimeMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatConfig) GetMaxMessageLength() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxMessageLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatConfig) GetOnlyAuthenticated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OnlyAuthenticated
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Общая модель пользователя для всех сервисов
type User struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Username      string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_proto_forum_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{32}
}</span>

func (x *User) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        int64                  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[33]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[33]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{33}
}</span>

func (x *GetUserRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserProfileResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        int64                  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
        Username      string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        CreatedAt     int64                  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
        PostCount     int32                  `protobuf:"varint,4,opt,name=post_count,json=postCount,proto3" json:"post_count,omitempty"`
        CommentCount  int32                  `protobuf:"varint,5,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
        IsAdmin       bool                   `protobuf:"varint,6,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UserProfileResponse) Reset() <span class="cov0" title="0">{
        *x = UserProfileResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[34]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserProfileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserProfileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserProfileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[34]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserProfileResponse.ProtoReflect.Descriptor instead.
func (*UserProfileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{34}
}</span>

func (x *UserProfileResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfileResponse) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetPostCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetCommentCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Error struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          ErrorCode              `protobuf:"varint,1,opt,name=code,proto3,enum=proto.ErrorCode" json:"code,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Error) Reset() <span class="cov0" title="0">{
        *x = Error{}
        mi := &amp;file_proto_forum_proto_msgTypes[35]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Error) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Error) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Error) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[35]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{35}
}</span>

func (x *Error) GetCode() ErrorCode <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ErrorCode_ERROR_UNSPECIFIED</span>
}

func (x *Error) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CheckAdminRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        int64                  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CheckAdminRequest) Reset() <span class="cov0" title="0">{
        *x = CheckAdminRequest{}
        mi := &amp;file_proto_forum_proto_msgTypes[36]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CheckAdminRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckAdminRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckAdminRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[36]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckAdminRequest.ProtoReflect.Descriptor instead.
func (*CheckAdminRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{36}
}</span>

func (x *CheckAdminRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CheckAdminResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        IsAdmin       bool                   `protobuf:"varint,1,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CheckAdminResponse) Reset() <span class="cov0" title="0">{
        *x = CheckAdminResponse{}
        mi := &amp;file_proto_forum_proto_msgTypes[37]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CheckAdminResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckAdminResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckAdminResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[37]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckAdminResponse.ProtoReflect.Descriptor instead.
func (*CheckAdminResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{37}
}</span>

func (x *CheckAdminResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_proto_forum_proto protoreflect.FileDescriptor

const file_proto_forum_proto_rawDesc = "" +
        "\n" +
        "\x11proto/forum.proto\x12\x05proto\"\x0e\n" +
        "\fEmptyMessage\"I\n" +
        "\x0fRegisterRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\"y\n" +
        "\x10RegisterResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x03 \x01(\x03R\texpiresAt\"F\n" +
        "\fLoginRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\"\xa6\x01\n" +
        "\rLoginResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x03 \x01(\x03R\texpiresAt\x12.\n" +
        "\x04user\x18\x04 \x01(\v2\x1a.proto.UserProfileResponseR\x04user\":\n" +
        "\x13RefreshTokenRequest\x12#\n" +
        "\rrefresh_token\x18\x01 \x01(\tR\frefreshToken\"}\n" +
        "\x14RefreshTokenResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x03 \x01(\x03R\texpiresAt\"4\n" +
        "\x0fValidateRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\"}\n" +
        "\x10ValidateResponse\x12\x19\n" +
        "\bis_valid\x18\x01 \x01(\bR\aisValid\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\x03R\x06userId\x12\x1a\n" +
        "\busername\x18\x03 \x01(\tR\busername\x12\x19\n" +
        "\bis_admin\x18\x04 \x01(\bR\aisAdmin\"2\n" +
        "\rLogoutRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\"*\n" +
        "\x0eLogoutResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\"\xd0\x01\n" +
        "\x04Post\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\x12\x14\n" +
        "\x05title\x18\x02 \x01(\tR\x05title\x12\x18\n" +
        "\acontent\x18\x03 \x01(\tR\acontent\x12\x1b\n" +
        "\tauthor_id\x18\x04 \x01(\x03R\bauthorId\x12'\n" +
        "\x0fauthor_username\x18\x05 \x01(\tR\x0eauthorUsername\x12\x1d\n" +
        "\n" +
        "created_at\x18\x06 \x01(\x03R\tcreatedAt\x12#\n" +
        "\rcomment_count\x18\a \x01(\x05R\fcommentCount\"/\n" +
        "\fPostResponse\x12\x1f\n" +
        "\x04post\x18\x01 \x01(\v2\v.proto.PostR\x04post\"\x89\x01\n" +
        "\x11CreatePostRequest\x12\x14\n" +
        "\x05title\x18\x01 \x01(\tR\x05title\x12\x18\n" +
        "\acontent\x18\x02 \x01(\tR\acontent\x12\x1b\n" +
        "\tauthor_id\x18\x03 \x01(\x03R\bauthorId\x12'\n" +
        "\x0fauthor_username\x18\x04 \x01(\tR\x0eauthorUsername\")\n" +
        "\x0eGetPostRequest\x12\x17\n" +
        "\apost_id\x18\x01 \x01(\x03R\x06postId\"|\n" +
        "\x11UpdatePostRequest\x12\x17\n" +
        "\apost_id\x18\x01 \x01(\x03R\x06postId\x12\x19\n" +
        "\x05title\x18\x02 \x01(\tH\x00R\x05title\x88\x01\x01\x12\x1d\n" +
        "\acontent\x18\x03 \x01(\tH\x01R\acontent\x88\x01\x01B\b\n" +
        "\x06_titleB\n" +
        "\n" +
        "\b_content\",\n" +
        "\x11DeletePostRequest\x12\x17\n" +
        "\apost_id\x18\x01 \x01(\x03R\x06postId\"B\n" +
        "\x10ListPostsRequest\x12 \n" +
        "\tauthor_id\x18\x01 \x01(\x03H\x00R\bauthorId\x88\x01\x01B\f\n" +
        "\n" +
        "_author_id\"W\n" +
        "\x11ListPostsResponse\x12!\n" +
        "\x05posts\x18\x01 \x03(\v2\v.proto.PostR\x05posts\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\"\xb1\x01\n" +
        "\aComment\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\x12\x18\n" +
        "\acontent\x18\x02 \x01(\tR\acontent\x12\x1b\n" +
        "\tauthor_id\x18\x03 \x01(\x03R\bauthorId\x12'\n" +
        "\x0fauthor_username\x18\x04 \x01(\tR\x0eauthorUsername\x12\x17\n" +
        "\apost_id\x18\x05 \x01(\x03R\x06postId\x12\x1d\n" +
        "\n" +
        "created_at\x18\x06 \x01(\x03R\tcreatedAt\";\n" +
        "\x0fCommentResponse\x12(\n" +
        "\acomment\x18\x01 \x01(\v2\x0e.proto.CommentR\acomment\"\x8f\x01\n" +
        "\x14CreateCommentRequest\x12\x18\n" +
        "\acontent\x18\x01 \x01(\tR\acontent\x12\x1b\n" +
        "\tauthor_id\x18\x02 \x01(\x03R\bauthorId\x12\x17\n" +
        "\apost_id\x18\x03 \x01(\x03R\x06postId\x12'\n" +
        "\x0fauthor_username\x18\x04 \x01(\tR\x0eauthorUsername\"2\n" +
        "\x11GetCommentRequest\x12\x1d\n" +
        "\n" +
        "comment_id\x18\x01 \x01(\x03R\tcommentId\"5\n" +
        "\x1aGetCommentsByPostIDRequest\x12\x17\n" +
        "\apost_id\x18\x01 \x01(\x03R\x06postId\".\n" +
        "\x13ListCommentsRequest\x12\x17\n" +
        "\apost_id\x18\x01 \x01(\x03R\x06postId\"c\n" +
        "\x14ListCommentsResponse\x12*\n" +
        "\bcomments\x18\x01 \x03(\v2\x0e.proto.CommentR\bcomments\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\"`\n" +
        "\x14UpdateCommentRequest\x12\x1d\n" +
        "\n" +
        "comment_id\x18\x01 \x01(\x03R\tcommentId\x12\x1d\n" +
        "\acontent\x18\x02 \x01(\tH\x00R\acontent\x88\x01\x01B\n" +
        "\n" +
        "\b_content\"5\n" +
        "\x14DeleteCommentRequest\x12\x1d\n" +
        "\n" +
        "comment_id\x18\x01 \x01(\x03R\tcommentId\"_\n" +
        "\vChatMessage\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\x03R\x06userId\x12\x18\n" +
        "\acontent\x18\x02 \x01(\tR\acontent\x12\x1d\n" +
        "\n" +
        "created_at\x18\x03 \x01(\x03R\tcreatedAt\"\x14\n" +
        "\x12GetMessagesRequest\"f\n" +
        "\x13GetMessagesResponse\x12.\n" +
        "\bmessages\x18\x01 \x03(\v2\x12.proto.ChatMessageR\bmessages\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\"\xa3\x01\n" +
        "\n" +
        "ChatConfig\x128\n" +
        "\x18message_lifetime_minutes\x18\x01 \x01(\x05R\x16messageLifetimeMinutes\x12,\n" +
        "\x12max_message_length\x18\x02 \x01(\x05R\x10maxMessageLength\x12-\n" +
        "\x12only_authenticated\x18\x03 \x01(\bR\x11onlyAuthenticated\"Q\n" +
        "\x04User\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\x03R\x02id\x12\x1a\n" +
        "\busername\x18\x02 \x01(\tR\busername\x12\x1d\n" +
        "\n" +
        "created_at\x18\x03 \x01(\x03R\tcreatedAt\")\n" +
        "\x0eGetUserRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\x03R\x06userId\"\xc7\x01\n" +
        "\x13UserProfileResponse\x12\x16\n" +
        "\x06userId\x18\x01 \x01(\x03R\x06userId\x12\x1a\n" +
        "\busername\x18\x02 \x01(\tR\busername\x12\x1d\n" +
        "\n" +
        "created_at\x18\x03 \x01(\x03R\tcreatedAt\x12\x1d\n" +
        "\n" +
        "post_count\x18\x04 \x01(\x05R\tpostCount\x12#\n" +
        "\rcomment_count\x18\x05 \x01(\x05R\fcommentCount\x12\x19\n" +
        "\bis_admin\x18\x06 \x01(\bR\aisAdmin\"G\n" +
        "\x05Error\x12$\n" +
        "\x04code\x18\x01 \x01(\x0e2\x10.proto.ErrorCodeR\x04code\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\",\n" +
        "\x11CheckAdminRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\x03R\x06userId\"/\n" +
        "\x12CheckAdminResponse\x12\x19\n" +
        "\bis_admin\x18\x01 \x01(\bR\aisAdmin*\xb0\x01\n" +
        "\tErrorCode\x12\x15\n" +
        "\x11ERROR_UNSPECIFIED\x10\x00\x12\x1d\n" +
        "\x19ERROR_INVALID_CREDENTIALS\x10\x01\x12\x18\n" +
        "\x14ERROR_USER_NOT_FOUND\x10\x02\x12\x1d\n" +
        "\x19ERROR_USER_ALREADY_EXISTS\x10\x03\x12\x17\n" +
        "\x13ERROR_TOKEN_EXPIRED\x10\x04\x12\x1b\n" +
        "\x17ERROR_PERMISSION_DENIED\x10\x052\xcb\x03\n" +
        "\vAuthService\x12;\n" +
        "\bRegister\x12\x16.proto.RegisterRequest\x1a\x17.proto.RegisterResponse\x12@\n" +
        "\vGetUserByID\x12\x15.proto.GetUserRequest\x1a\x1a.proto.UserProfileResponse\x122\n" +
        "\x05Login\x12\x13.proto.LoginRequest\x1a\x14.proto.LoginResponse\x12G\n" +
        "\fRefreshToken\x12\x1a.proto.RefreshTokenRequest\x1a\x1b.proto.RefreshTokenResponse\x12@\n" +
        "\rValidateToken\x12\x16.proto.ValidateRequest\x1a\x17.proto.ValidateResponse\x125\n" +
        "\x06Logout\x12\x14.proto.LogoutRequest\x1a\x15.proto.LogoutResponse\x12G\n" +
        "\x10CheckAdminStatus\x12\x18.proto.CheckAdminRequest\x1a\x19.proto.CheckAdminResponse2\xdd\x06\n" +
        "\fForumService\x12;\n" +
        "\n" +
        "CreatePost\x12\x18.proto.CreatePostRequest\x1a\x13.proto.PostResponse\x125\n" +
        "\aGetPost\x12\x15.proto.GetPostRequest\x1a\x13.proto.PostResponse\x12;\n" +
        "\n" +
        "UpdatePost\x12\x18.proto.UpdatePostRequest\x1a\x13.proto.PostResponse\x12;\n" +
        "\n" +
        "DeletePost\x12\x18.proto.DeletePostRequest\x1a\x13.proto.EmptyMessage\x12:\n" +
        "\x05Posts\x12\x17.proto.ListPostsRequest\x1a\x18.proto.ListPostsResponse\x12D\n" +
        "\rCreateComment\x12\x1b.proto.CreateCommentRequest\x1a\x16.proto.CommentResponse\x12B\n" +
        "\x0eGetCommentByID\x12\x18.proto.GetCommentRequest\x1a\x16.proto.CommentResponse\x12M\n" +
        "\vGetByPostID\x12!.proto.GetCommentsByPostIDRequest\x1a\x1b.proto.ListCommentsResponse\x12C\n" +
        "\bComments\x12\x1a.proto.ListCommentsRequest\x1a\x1b.proto.ListCommentsResponse\x12D\n" +
        "\rUpdateComment\x12\x1b.proto.UpdateCommentRequest\x1a\x16.proto.CommentResponse\x12A\n" +
        "\rDeleteComment\x12\x1b.proto.DeleteCommentRequest\x1a\x13.proto.EmptyMessage\x126\n" +
        "\vSendMessage\x12\x12.proto.ChatMessage\x1a\x13.proto.EmptyMessage\x12D\n" +
        "\vGetMessages\x12\x19.proto.GetMessagesRequest\x1a\x1a.proto.GetMessagesResponseB\fZ\n" +
        "back/protob\x06proto3"

var (
        file_proto_forum_proto_rawDescOnce sync.Once
        file_proto_forum_proto_rawDescData []byte
)

func file_proto_forum_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_forum_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_forum_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_forum_proto_rawDesc), len(file_proto_forum_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_forum_proto_rawDescData</span>
}

var file_proto_forum_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_forum_proto_msgTypes = make([]protoimpl.MessageInfo, 38)
var file_proto_forum_proto_goTypes = []any{
        (ErrorCode)(0),                     // 0: proto.ErrorCode
        (*EmptyMessage)(nil),               // 1: proto.EmptyMessage
        (*RegisterRequest)(nil),            // 2: proto.RegisterRequest
        (*RegisterResponse)(nil),           // 3: proto.RegisterResponse
        (*LoginRequest)(nil),               // 4: proto.LoginRequest
        (*LoginResponse)(nil),              // 5: proto.LoginResponse
        (*RefreshTokenRequest)(nil),        // 6: proto.RefreshTokenRequest
        (*RefreshTokenResponse)(nil),       // 7: proto.RefreshTokenResponse
        (*ValidateRequest)(nil),            // 8: proto.ValidateRequest
        (*ValidateResponse)(nil),           // 9: proto.ValidateResponse
        (*LogoutRequest)(nil),              // 10: proto.LogoutRequest
        (*LogoutResponse)(nil),             // 11: proto.LogoutResponse
        (*Post)(nil),                       // 12: proto.Post
        (*PostResponse)(nil),               // 13: proto.PostResponse
        (*CreatePostRequest)(nil),          // 14: proto.CreatePostRequest
        (*GetPostRequest)(nil),             // 15: proto.GetPostRequest
        (*UpdatePostRequest)(nil),          // 16: proto.UpdatePostRequest
        (*DeletePostRequest)(nil),          // 17: proto.DeletePostRequest
        (*ListPostsRequest)(nil),           // 18: proto.ListPostsRequest
        (*ListPostsResponse)(nil),          // 19: proto.ListPostsResponse
        (*Comment)(nil),                    // 20: proto.Comment
        (*CommentResponse)(nil),            // 21: proto.CommentResponse
        (*CreateCommentRequest)(nil),       // 22: proto.CreateCommentRequest
        (*GetCommentRequest)(nil),          // 23: proto.GetCommentRequest
        (*GetCommentsByPostIDRequest)(nil), // 24: proto.GetCommentsByPostIDRequest
        (*ListCommentsRequest)(nil),        // 25: proto.ListCommentsRequest
        (*ListCommentsResponse)(nil),       // 26: proto.ListCommentsResponse
        (*UpdateCommentRequest)(nil),       // 27: proto.UpdateCommentRequest
        (*DeleteCommentRequest)(nil),       // 28: proto.DeleteCommentRequest
        (*ChatMessage)(nil),                // 29: proto.ChatMessage
        (*GetMessagesRequest)(nil),         // 30: proto.GetMessagesRequest
        (*GetMessagesResponse)(nil),        // 31: proto.GetMessagesResponse
        (*ChatConfig)(nil),                 // 32: proto.ChatConfig
        (*User)(nil),                       // 33: proto.User
        (*GetUserRequest)(nil),             // 34: proto.GetUserRequest
        (*UserProfileResponse)(nil),        // 35: proto.UserProfileResponse
        (*Error)(nil),                      // 36: proto.Error
        (*CheckAdminRequest)(nil),          // 37: proto.CheckAdminRequest
        (*CheckAdminResponse)(nil),         // 38: proto.CheckAdminResponse
}
var file_proto_forum_proto_depIdxs = []int32{
        35, // 0: proto.LoginResponse.user:type_name -&gt; proto.UserProfileResponse
        12, // 1: proto.PostResponse.post:type_name -&gt; proto.Post
        12, // 2: proto.ListPostsResponse.posts:type_name -&gt; proto.Post
        20, // 3: proto.CommentResponse.comment:type_name -&gt; proto.Comment
        20, // 4: proto.ListCommentsResponse.comments:type_name -&gt; proto.Comment
        29, // 5: proto.GetMessagesResponse.messages:type_name -&gt; proto.ChatMessage
        0,  // 6: proto.Error.code:type_name -&gt; proto.ErrorCode
        2,  // 7: proto.AuthService.Register:input_type -&gt; proto.RegisterRequest
        34, // 8: proto.AuthService.GetUserByID:input_type -&gt; proto.GetUserRequest
        4,  // 9: proto.AuthService.Login:input_type -&gt; proto.LoginRequest
        6,  // 10: proto.AuthService.RefreshToken:input_type -&gt; proto.RefreshTokenRequest
        8,  // 11: proto.AuthService.ValidateToken:input_type -&gt; proto.ValidateRequest
        10, // 12: proto.AuthService.Logout:input_type -&gt; proto.LogoutRequest
        37, // 13: proto.AuthService.CheckAdminStatus:input_type -&gt; proto.CheckAdminRequest
        14, // 14: proto.ForumService.CreatePost:input_type -&gt; proto.CreatePostRequest
        15, // 15: proto.ForumService.GetPost:input_type -&gt; proto.GetPostRequest
        16, // 16: proto.ForumService.UpdatePost:input_type -&gt; proto.UpdatePostRequest
        17, // 17: proto.ForumService.DeletePost:input_type -&gt; proto.DeletePostRequest
        18, // 18: proto.ForumService.Posts:input_type -&gt; proto.ListPostsRequest
        22, // 19: proto.ForumService.CreateComment:input_type -&gt; proto.CreateCommentRequest
        23, // 20: proto.ForumService.GetCommentByID:input_type -&gt; proto.GetCommentRequest
        24, // 21: proto.ForumService.GetByPostID:input_type -&gt; proto.GetCommentsByPostIDRequest
        25, // 22: proto.ForumService.Comments:input_type -&gt; proto.ListCommentsRequest
        27, // 23: proto.ForumService.UpdateComment:input_type -&gt; proto.UpdateCommentRequest
        28, // 24: proto.ForumService.DeleteComment:input_type -&gt; proto.DeleteCommentRequest
        29, // 25: proto.ForumService.SendMessage:input_type -&gt; proto.ChatMessage
        30, // 26: proto.ForumService.GetMessages:input_type -&gt; proto.GetMessagesRequest
        3,  // 27: proto.AuthService.Register:output_type -&gt; proto.RegisterResponse
        35, // 28: proto.AuthService.GetUserByID:output_type -&gt; proto.UserProfileResponse
        5,  // 29: proto.AuthService.Login:output_type -&gt; proto.LoginResponse
        7,  // 30: proto.AuthService.RefreshToken:output_type -&gt; proto.RefreshTokenResponse
        9,  // 31: proto.AuthService.ValidateToken:output_type -&gt; proto.ValidateResponse
        11, // 32: proto.AuthService.Logout:output_type -&gt; proto.LogoutResponse
        38, // 33: proto.AuthService.CheckAdminStatus:output_type -&gt; proto.CheckAdminResponse
        13, // 34: proto.ForumService.CreatePost:output_type -&gt; proto.PostResponse
        13, // 35: proto.ForumService.GetPost:output_type -&gt; proto.PostResponse
        13, // 36: proto.ForumService.UpdatePost:output_type -&gt; proto.PostResponse
        1,  // 37: proto.ForumService.DeletePost:output_type -&gt; proto.EmptyMessage
        19, // 38: proto.ForumService.Posts:output_type -&gt; proto.ListPostsResponse
        21, // 39: proto.ForumService.CreateComment:output_type -&gt; proto.CommentResponse
        21, // 40: proto.ForumService.GetCommentByID:output_type -&gt; proto.CommentResponse
        26, // 41: proto.ForumService.GetByPostID:output_type -&gt; proto.ListCommentsResponse
        26, // 42: proto.ForumService.Comments:output_type -&gt; proto.ListCommentsResponse
        21, // 43: proto.ForumService.UpdateComment:output_type -&gt; proto.CommentResponse
        1,  // 44: proto.ForumService.DeleteComment:output_type -&gt; proto.EmptyMessage
        1,  // 45: proto.ForumService.SendMessage:output_type -&gt; proto.EmptyMessage
        31, // 46: proto.ForumService.GetMessages:output_type -&gt; proto.GetMessagesResponse
        27, // [27:47] is the sub-list for method output_type
        7,  // [7:27] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_forum_proto_init() }</span>
func file_proto_forum_proto_init() <span class="cov8" title="1">{
        if File_proto_forum_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_proto_forum_proto_msgTypes[15].OneofWrappers = []any{}
        file_proto_forum_proto_msgTypes[17].OneofWrappers = []any{}
        file_proto_forum_proto_msgTypes[26].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_forum_proto_rawDesc), len(file_proto_forum_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   38,
                        NumExtensions: 0,
                        NumServices:   2,
                },
                GoTypes:           file_proto_forum_proto_goTypes,
                DependencyIndexes: file_proto_forum_proto_depIdxs,
                EnumInfos:         file_proto_forum_proto_enumTypes,
                MessageInfos:      file_proto_forum_proto_msgTypes,
        }.Build()
        File_proto_forum_proto = out.File
        file_proto_forum_proto_goTypes = nil
        file_proto_forum_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: proto/forum.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        AuthService_Register_FullMethodName         = "/proto.AuthService/Register"
        AuthService_GetUserByID_FullMethodName      = "/proto.AuthService/GetUserByID"
        AuthService_Login_FullMethodName            = "/proto.AuthService/Login"
        AuthService_RefreshToken_FullMethodName     = "/proto.AuthService/RefreshToken"
        AuthService_ValidateToken_FullMethodName    = "/proto.AuthService/ValidateToken"
        AuthService_Logout_FullMethodName           = "/proto.AuthService/Logout"
        AuthService_CheckAdminStatus_FullMethodName = "/proto.AuthService/CheckAdminStatus"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ================== Auth Service ==================
type AuthServiceClient interface {
        // Register creates a new user account
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        // User operations
        GetUserByID(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error)
        // Login authenticates user and returns access/refresh tokens
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
        ValidateToken(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
        CheckAdminStatus(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (*CheckAdminResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetUserByID(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UserProfileResponse)
        err := c.cc.Invoke(ctx, AuthService_GetUserByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RefreshTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ValidateResponse)
        err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) CheckAdminStatus(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (*CheckAdminResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CheckAdminResponse)
        err := c.cc.Invoke(ctx, AuthService_CheckAdminStatus_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// ================== Auth Service ==================
type AuthServiceServer interface {
        // Register creates a new user account
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        // User operations
        GetUserByID(context.Context, *GetUserRequest) (*UserProfileResponse, error)
        // Login authenticates user and returns access/refresh tokens
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
        ValidateToken(context.Context, *ValidateRequest) (*ValidateResponse, error)
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        CheckAdminStatus(context.Context, *CheckAdminRequest) (*CheckAdminResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetUserByID(context.Context, *GetUserRequest) (*UserProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserByID not implemented")
}</span>
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateRequest) (*ValidateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServiceServer) CheckAdminStatus(context.Context, *CheckAdminRequest) (*CheckAdminResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CheckAdminStatus not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAuthServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;AuthService_ServiceDesc, srv)</span>
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_GetUserByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserByID(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RefreshToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ValidateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ValidateToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_CheckAdminStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CheckAdminRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckAdminStatus(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_CheckAdminStatus_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckAdminStatus(ctx, req.(*CheckAdminRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "proto.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _AuthService_Register_Handler,
                },
                {
                        MethodName: "GetUserByID",
                        Handler:    _AuthService_GetUserByID_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "RefreshToken",
                        Handler:    _AuthService_RefreshToken_Handler,
                },
                {
                        MethodName: "ValidateToken",
                        Handler:    _AuthService_ValidateToken_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _AuthService_Logout_Handler,
                },
                {
                        MethodName: "CheckAdminStatus",
                        Handler:    _AuthService_CheckAdminStatus_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/forum.proto",
}

const (
        ForumService_CreatePost_FullMethodName     = "/proto.ForumService/CreatePost"
        ForumService_GetPost_FullMethodName        = "/proto.ForumService/GetPost"
        ForumService_UpdatePost_FullMethodName     = "/proto.ForumService/UpdatePost"
        ForumService_DeletePost_FullMethodName     = "/proto.ForumService/DeletePost"
        ForumService_Posts_FullMethodName          = "/proto.ForumService/Posts"
        ForumService_CreateComment_FullMethodName  = "/proto.ForumService/CreateComment"
        ForumService_GetCommentByID_FullMethodName = "/proto.ForumService/GetCommentByID"
        ForumService_GetByPostID_FullMethodName    = "/proto.ForumService/GetByPostID"
        ForumService_Comments_FullMethodName       = "/proto.ForumService/Comments"
        ForumService_UpdateComment_FullMethodName  = "/proto.ForumService/UpdateComment"
        ForumService_DeleteComment_FullMethodName  = "/proto.ForumService/DeleteComment"
        ForumService_SendMessage_FullMethodName    = "/proto.ForumService/SendMessage"
        ForumService_GetMessages_FullMethodName    = "/proto.ForumService/GetMessages"
)

// ForumServiceClient is the client API for ForumService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ================== Forum Service ==================
type ForumServiceClient interface {
        // Post operations
        CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        UpdatePost(ctx context.Context, in *UpdatePostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*EmptyMessage, error)
        Posts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error)
        // Comment operations
        CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        GetCommentByID(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        GetByPostID(ctx context.Context, in *GetCommentsByPostIDRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error)
        Comments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error)
        UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*EmptyMessage, error)
        // Chat operations
        SendMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*EmptyMessage, error)
        GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
}

type forumServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewForumServiceClient(cc grpc.ClientConnInterface) ForumServiceClient <span class="cov0" title="0">{
        return &amp;forumServiceClient{cc}
}</span>

func (c *forumServiceClient) CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, ForumService_CreatePost_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, ForumService_GetPost_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) UpdatePost(ctx context.Context, in *UpdatePostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, ForumService_UpdatePost_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, ForumService_DeletePost_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) Posts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListPostsResponse)
        err := c.cc.Invoke(ctx, ForumService_Posts_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, ForumService_CreateComment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetCommentByID(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, ForumService_GetCommentByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetByPostID(ctx context.Context, in *GetCommentsByPostIDRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListCommentsResponse)
        err := c.cc.Invoke(ctx, ForumService_GetByPostID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) Comments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListCommentsResponse)
        err := c.cc.Invoke(ctx, ForumService_Comments_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, ForumService_UpdateComment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, ForumService_DeleteComment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) SendMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, ForumService_SendMessage_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetMessagesResponse)
        err := c.cc.Invoke(ctx, ForumService_GetMessages_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ForumServiceServer is the server API for ForumService service.
// All implementations must embed UnimplementedForumServiceServer
// for forward compatibility.
//
// ================== Forum Service ==================
type ForumServiceServer interface {
        // Post operations
        CreatePost(context.Context, *CreatePostRequest) (*PostResponse, error)
        GetPost(context.Context, *GetPostRequest) (*PostResponse, error)
        UpdatePost(context.Context, *UpdatePostRequest) (*PostResponse, error)
        DeletePost(context.Context, *DeletePostRequest) (*EmptyMessage, error)
        Posts(context.Context, *ListPostsRequest) (*ListPostsResponse, error)
        // Comment operations
        CreateComment(context.Context, *CreateCommentRequest) (*CommentResponse, error)
        GetCommentByID(context.Context, *GetCommentRequest) (*CommentResponse, error)
        GetByPostID(context.Context, *GetCommentsByPostIDRequest) (*ListCommentsResponse, error)
        Comments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error)
        UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error)
        DeleteComment(context.Context, *DeleteCommentRequest) (*EmptyMessage, error)
        // Chat operations
        SendMessage(context.Context, *ChatMessage) (*EmptyMessage, error)
        GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
        mustEmbedUnimplementedForumServiceServer()
}

// UnimplementedForumServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedForumServiceServer struct{}

func (UnimplementedForumServiceServer) CreatePost(context.Context, *CreatePostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}</span>
func (UnimplementedForumServiceServer) GetPost(context.Context, *GetPostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}</span>
func (UnimplementedForumServiceServer) UpdatePost(context.Context, *UpdatePostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}</span>
func (UnimplementedForumServiceServer) DeletePost(context.Context, *DeletePostRequest) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}</span>
func (UnimplementedForumServiceServer) Posts(context.Context, *ListPostsRequest) (*ListPostsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Posts not implemented")
}</span>
func (UnimplementedForumServiceServer) CreateComment(context.Context, *CreateCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateComment not implemented")
}</span>
func (UnimplementedForumServiceServer) GetCommentByID(context.Context, *GetCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCommentByID not implemented")
}</span>
func (UnimplementedForumServiceServer) GetByPostID(context.Context, *GetCommentsByPostIDRequest) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetByPostID not implemented")
}</span>
func (UnimplementedForumServiceServer) Comments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Comments not implemented")
}</span>
func (UnimplementedForumServiceServer) UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateComment not implemented")
}</span>
func (UnimplementedForumServiceServer) DeleteComment(context.Context, *DeleteCommentRequest) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}</span>
func (UnimplementedForumServiceServer) SendMessage(context.Context, *ChatMessage) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}</span>
func (UnimplementedForumServiceServer) GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}</span>
func (UnimplementedForumServiceServer) mustEmbedUnimplementedForumServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedForumServiceServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeForumServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForumServiceServer will
// result in compilation errors.
type UnsafeForumServiceServer interface {
        mustEmbedUnimplementedForumServiceServer()
}

func RegisterForumServiceServer(s grpc.ServiceRegistrar, srv ForumServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedForumServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;ForumService_ServiceDesc, srv)</span>
}

func _ForumService_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreatePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreatePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_CreatePost_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreatePost(ctx, req.(*CreatePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetPost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_GetPost_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetPost(ctx, req.(*GetPostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdatePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdatePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_UpdatePost_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdatePost(ctx, req.(*UpdatePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeletePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeletePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_DeletePost_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeletePost(ctx, req.(*DeletePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_Posts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListPostsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Posts(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_Posts_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Posts(ctx, req.(*ListPostsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreateComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_CreateComment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreateComment(ctx, req.(*CreateCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetCommentByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetCommentByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_GetCommentByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetCommentByID(ctx, req.(*GetCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetByPostID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetCommentsByPostIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetByPostID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_GetByPostID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetByPostID(ctx, req.(*GetCommentsByPostIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_Comments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListCommentsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Comments(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_Comments_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Comments(ctx, req.(*ListCommentsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_UpdateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_UpdateComment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateComment(ctx, req.(*UpdateCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeleteComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_DeleteComment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ChatMessage)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).SendMessage(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_SendMessage_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).SendMessage(ctx, req.(*ChatMessage))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMessagesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetMessages(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ForumService_GetMessages_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetMessages(ctx, req.(*GetMessagesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ForumService_ServiceDesc is the grpc.ServiceDesc for ForumService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ForumService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "proto.ForumService",
        HandlerType: (*ForumServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreatePost",
                        Handler:    _ForumService_CreatePost_Handler,
                },
                {
                        MethodName: "GetPost",
                        Handler:    _ForumService_GetPost_Handler,
                },
                {
                        MethodName: "UpdatePost",
                        Handler:    _ForumService_UpdatePost_Handler,
                },
                {
                        MethodName: "DeletePost",
                        Handler:    _ForumService_DeletePost_Handler,
                },
                {
                        MethodName: "Posts",
                        Handler:    _ForumService_Posts_Handler,
                },
                {
                        MethodName: "CreateComment",
                        Handler:    _ForumService_CreateComment_Handler,
                },
                {
                        MethodName: "GetCommentByID",
                        Handler:    _ForumService_GetCommentByID_Handler,
                },
                {
                        MethodName: "GetByPostID",
                        Handler:    _ForumService_GetByPostID_Handler,
                },
                {
                        MethodName: "Comments",
                        Handler:    _ForumService_Comments_Handler,
                },
                {
                        MethodName: "UpdateComment",
                        Handler:    _ForumService_UpdateComment_Handler,
                },
                {
                        MethodName: "DeleteComment",
                        Handler:    _ForumService_DeleteComment_Handler,
                },
                {
                        MethodName: "SendMessage",
                        Handler:    _ForumService_SendMessage_Handler,
                },
                {
                        MethodName: "GetMessages",
                        Handler:    _ForumService_GetMessages_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/forum.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
