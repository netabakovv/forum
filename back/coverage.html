
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>main: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">back/auth_service/cmd/main/main.go (0.0%)</option>
				
				<option value="file1">back/auth_service/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">back/auth_service/internal/delivery/grpc/server.go (0.0%)</option>
				
				<option value="file3">back/auth_service/internal/delivery/http/auth_handler.go (0.0%)</option>
				
				<option value="file4">back/auth_service/internal/entities/token.go (0.0%)</option>
				
				<option value="file5">back/auth_service/internal/entities/user.go (0.0%)</option>
				
				<option value="file6">back/auth_service/internal/pkg/database/postgres.go (0.0%)</option>
				
				<option value="file7">back/auth_service/internal/repository/auth.go (0.0%)</option>
				
				<option value="file8">back/auth_service/internal/service/mocks/token_mocks.go (0.0%)</option>
				
				<option value="file9">back/auth_service/internal/service/token_service.go (0.0%)</option>
				
				<option value="file10">back/auth_service/internal/usecase/auth.go (25.0%)</option>
				
				<option value="file11">back/auth_service/internal/usecase/mocks/repo_mocks.go (0.0%)</option>
				
				<option value="file12">back/forum_service/cmd/migrations/migrations.go (0.0%)</option>
				
				<option value="file13">back/forum_service/internal/delivery/http/middleware.go (0.0%)</option>
				
				<option value="file14">back/forum_service/internal/delivery/ws/chat.go (0.0%)</option>
				
				<option value="file15">back/forum_service/internal/repository/forum.go (82.5%)</option>
				
				<option value="file16">back/forum_service/internal/repository/mocks/repo_mocks.go (77.5%)</option>
				
				<option value="file17">back/forum_service/internal/service/cleanup.go (0.0%)</option>
				
				<option value="file18">back/forum_service/internal/usecase/chat.go (0.0%)</option>
				
				<option value="file19">back/forum_service/internal/usecase/forum.go (100.0%)</option>
				
				<option value="file20">back/forum_service/internal/usecase/mocks/ucChat_mocks.go (82.6%)</option>
				
				<option value="file21">back/forum_service/internal/usecase/mocks/uc_mocks.go (0.0%)</option>
				
				<option value="file22">back/pkg/database/migrate.go (0.0%)</option>
				
				<option value="file23">back/pkg/logger/interface.go (100.0%)</option>
				
				<option value="file24">back/pkg/logger/stdlogger.go (75.0%)</option>
				
				<option value="file25">back/proto/forum.pb.go (1.2%)</option>
				
				<option value="file26">back/proto/forum_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "database/sql"
        "fmt"
        "net"
        "os"
        "os/signal"
        "syscall"

        "back/auth_service/internal/delivery/grpc"
        "back/auth_service/internal/repository"
        "back/auth_service/internal/service"
        "back/auth_service/internal/usecase"
        "back/pkg/logger"
        pb "back/proto"

        _ "github.com/lib/pq"
        "github.com/spf13/viper"
        ggrpc "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        log := logger.NewStdLogger()

        // Инициализация конфигурации
        if err := initConfig(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("ошибка инициализации конфига",
                        logger.NewField("error", err))
        }</span>

        // Инициализация репозиториев
        <span class="cov0" title="0">db := initDB(log)
        defer db.Close()

        userRepo := repository.NewUserRepository(db, log)
        tokenRepo := repository.NewTokenRepository(db, log)

        log.Info("репозитории инициализированы успешно")

        // Инициализация сервисов с конфигом
        tokenService := service.NewTokenService(
                viper.GetString("auth.jwt_secret"),
                viper.GetDuration("auth.access_token_ttl"),
                viper.GetDuration("auth.refresh_token_ttl"),
                log,
        )

        log.Info("сервисы инициализированы успешно")

        // Инициализация usecase
        authUC := usecase.NewAuthUsecase(userRepo, tokenRepo, tokenService, log)

        log.Info("use-case'ы инициализированы успешно")

        // Инициализация gRPC сервера
        server := grpc.NewAuthServer(authUC, tokenService, log)

        s := ggrpc.NewServer()
        pb.RegisterAuthServiceServer(s, server)

        // Для работы рефлексии (опционально)
        reflection.Register(s)

        // Запуск gRPC сервера
        port := viper.GetString("auth_service.port")
        listener, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось запустить прослушивание порта",
                        logger.NewField("error", err))
        }</span>

        // Graceful shutdown
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info("запуск gRPC сервера на порту",
                        logger.NewField("port", port))
                if err := s.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("ошибка при запуске сервера",
                                logger.NewField("error", err))
                }</span>
        }()

        // Ожидание сигнала для graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("начало graceful shutdown")
        s.GracefulStop()
        log.Info("сервер остановлен")</span>
}

func initConfig() error <span class="cov0" title="0">{
        viper.SetConfigFile("./config.yaml")
        return viper.ReadInConfig()
}</span>

func initDB(log logger.Logger) *sql.DB <span class="cov0" title="0">{
        // Используем строку подключения из конфига
        dbURL := viper.GetString("authPath")
        log.Info(dbURL)

        db, err := sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось подключиться к базе данных",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("не удалось проверить соединение с базой данных",
                        logger.NewField("error", err))
        }</span>

        <span class="cov0" title="0">log.Info("успешное подключение к базе данных")
        return db</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package server

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v5"
        "log"
)

func Postgres() <span class="cov0" title="0">{
        // URL подключения: postgres://user:password@host:port/database
        connStr := "postgres://postgres:1@localhost:5555/auth?sslmode=disable"

        // Подключение к базе
        conn, err := pgx.Connect(context.Background(), connStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Ошибка подключения:", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close(context.Background()) // Закрыть подключение при выходе

        // Проверка подключения
        err = conn.Ping(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Ошибка ping:", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Успешное подключение к PostgreSQL!")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package grpc

import (
        "back/auth_service/internal/service"
        "back/auth_service/internal/usecase"
        "back/pkg/errors"
        "back/pkg/logger"
        pb "back/proto"
        "context"
        "net/http"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type AuthServer struct {
        pb.UnimplementedAuthServiceServer
        authUC       *usecase.AuthUsecase
        tokenService *service.TokenService
        logger       logger.Logger
}

func NewAuthServer(authUC *usecase.AuthUsecase, tokenService *service.TokenService, logger logger.Logger) *AuthServer <span class="cov0" title="0">{
        return &amp;AuthServer{
                authUC:       authUC,
                tokenService: tokenService,
                logger:       logger,
        }
}</span>

// Register создает нового пользователя и возвращает токены доступа
func (s *AuthServer) Register(ctx context.Context, req *pb.RegisterRequest) (*pb.RegisterResponse, error) <span class="cov0" title="0">{
        if req.Username == "" || req.Password == "" </span><span class="cov0" title="0">{
                s.logger.Warn("invalid register credentials provided")
                return nil, status.Error(codes.InvalidArgument, "username and password are required")
        }</span>

        <span class="cov0" title="0">tokens, err := s.authUC.Register(ctx, req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("registration failed",
                        logger.NewField("error", err),
                        logger.NewField("username", req.Username),
                )
                return nil, status.Error(codes.Internal, "failed to register user")
        }</span>

        <span class="cov0" title="0">return &amp;pb.RegisterResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresAt:    tokens.ExpiresAt.Unix(), // используем Unix timestamp
        }, nil</span>
}

// Login аутентифицирует пользователя и возвращает токены доступа
func (s *AuthServer) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) <span class="cov0" title="0">{
        // Проверяем контекст на отмену
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                s.logger.Error("context error",
                        logger.NewField("error", ctx.Err()),
                )
                return nil, status.Error(codes.Canceled, "request canceled")
        }</span>

        <span class="cov0" title="0">s.logger.Info("login request received",
                logger.NewField("username", req.Username),
        )

        if req.Username == "" || req.Password == "" </span><span class="cov0" title="0">{
                s.logger.Warn("invalid login credentials provided")
                return nil, status.Error(codes.InvalidArgument, "username and password are required")
        }</span>

        <span class="cov0" title="0">tokens, err := s.authUC.Login(ctx, req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case errors.ErrInvalidCredentials:<span class="cov0" title="0">
                        s.logger.Warn("invalid credentials",
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.Unauthenticated, "invalid credentials")</span>
                case errors.ErrUserNotFound:<span class="cov0" title="0">
                        s.logger.Warn("user not found",
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.NotFound, "user not found")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("login failed",
                                logger.NewField("error", err),
                                logger.NewField("username", req.Username),
                        )
                        return nil, status.Error(codes.Internal, "internal error")</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("login successful",
                logger.NewField("username", req.Username),
        )

        return &amp;pb.LoginResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
                ExpiresAt:    tokens.ExpiresAt.Unix(), // используем Unix timestamp
        }, nil</span>
}

func (s *AuthServer) RefreshToken(ctx context.Context, req *pb.RefreshTokenRequest) (*pb.RefreshTokenResponse, error) <span class="cov0" title="0">{
        s.logger.Info("refresh token request received")

        if req.RefreshToken == "" </span><span class="cov0" title="0">{
                s.logger.Warn("empty refresh token provided")
                return nil, status.Error(codes.InvalidArgument, "refresh token is required")
        }</span>

        <span class="cov0" title="0">tokens, err := s.authUC.RefreshTokens(ctx, req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case errors.ErrTokenInvalid:<span class="cov0" title="0">
                        s.logger.Warn("invalid refresh token")
                        return nil, status.Error(codes.Unauthenticated, "invalid refresh token")</span>
                case errors.ErrTokenExpired:<span class="cov0" title="0">
                        s.logger.Warn("refresh token expired")
                        return nil, status.Error(codes.Unauthenticated, "refresh token expired")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("failed to refresh tokens",
                                logger.NewField("error", err),
                        )
                        return nil, status.Error(codes.Internal, "failed to refresh tokens")</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("tokens refreshed successfully")
        return &amp;pb.RefreshTokenResponse{
                AccessToken:  tokens.AccessToken,
                RefreshToken: tokens.RefreshToken,
        }, nil</span>
}

func (s *AuthServer) ValidateToken(ctx context.Context, req *pb.ValidateRequest) (*pb.ValidateResponse, error) <span class="cov0" title="0">{
        s.logger.Info("token validation request received")

        if req.AccessToken == "" </span><span class="cov0" title="0">{
                s.logger.Warn("empty token provided")
                return &amp;pb.ValidateResponse{
                        IsValid: false,
                }, status.Error(codes.InvalidArgument, "token is required")
        }</span>

        <span class="cov0" title="0">claims, err := s.tokenService.ValidateToken(req.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case errors.ErrTokenExpired:<span class="cov0" title="0">
                        s.logger.Warn("token expired")
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.Unauthenticated, "token expired")</span>
                case errors.ErrTokenInvalid:<span class="cov0" title="0">
                        s.logger.Warn("invalid token")
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.InvalidArgument, "invalid token")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("token validation failed",
                                logger.NewField("error", err),
                        )
                        return &amp;pb.ValidateResponse{
                                IsValid: false,
                        }, status.Error(codes.Internal, "internal error")</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("token validated successfully",
                logger.NewField("user_id", claims.UserID),
        )

        return &amp;pb.ValidateResponse{
                UserId:   claims.UserID, // конвертируем int64 в string
                Username: claims.Username,
                IsAdmin:  claims.IsAdmin,
                IsValid:  true,
        }, nil</span>
}

func (s *AuthServer) Logout(ctx context.Context, req *pb.LogoutRequest) (*pb.LogoutResponse, error) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "контекст не может быть nil")
        }</span>

        <span class="cov0" title="0">if req.AccessToken == "" </span><span class="cov0" title="0">{
                s.logger.Warn("предоставлен пустой токен")
                return nil, status.Error(codes.InvalidArgument, "требуется токен доступа")
        }</span>

        <span class="cov0" title="0">claims, err := s.tokenService.ValidateToken(req.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case errors.ErrTokenExpired:<span class="cov0" title="0">
                        s.logger.Warn("токен просрочен")
                        return nil, status.Error(codes.Unauthenticated, "токен просрочен")</span>
                case errors.ErrTokenInvalid:<span class="cov0" title="0">
                        s.logger.Warn("недействительный токен")
                        return nil, status.Error(codes.InvalidArgument, "недействительный токен")</span>
                default:<span class="cov0" title="0">
                        s.logger.Error("ошибка проверки токена",
                                logger.NewField("error", err),
                        )
                        return nil, status.Error(codes.Internal, "внутренняя ошибка")</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("получен запрос на выход",
                logger.NewField("user_id", claims.UserID),
        )

        if err := s.authUC.RevokeTokens(ctx, claims.UserID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("не удалось отозвать токены",
                        logger.NewField("error", err),
                        logger.NewField("user_id", claims.UserID),
                )
                return nil, status.Error(codes.Internal, "не удалось выполнить выход")
        }</span>

        <span class="cov0" title="0">s.logger.Info("пользователь успешно вышел",
                logger.NewField("user_id", claims.UserID),
        )

        return &amp;pb.LogoutResponse{
                Success: true,
        }, nil</span>
}

func (s *AuthServer) CheckAdminStatus(ctx context.Context, req *pb.CheckAdminRequest) (*pb.CheckAdminResponse, error) <span class="cov0" title="0">{
        if req.UserId == 0 </span><span class="cov0" title="0">{
                s.logger.Warn("empty user id provided")
                return nil, status.Error(codes.InvalidArgument, "user id is required")
        }</span>

        <span class="cov0" title="0">s.logger.Info("check admin status request received",
                logger.NewField("user_id", req.UserId),
        )

        isAdmin, err := s.authUC.IsAdmin(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to check admin status",
                        logger.NewField("error", err),
                        logger.NewField("user_id", req.UserId),
                )
                return nil, status.Error(codes.Internal, "failed to check admin status")
        }</span>

        <span class="cov0" title="0">return &amp;pb.CheckAdminResponse{
                IsAdmin: isAdmin,
        }, nil</span>
}

func withCORS(h http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*") // на время dev можно *
                w.Header().Set("Access-Control-Allow-Headers", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "back/auth_service/internal/usecase"
        "encoding/json"
        "net/http"
)

type AuthHandler struct {
        uc usecase.AuthUsecase
}

func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                Username string `json:"username"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.uc.Register(r.Context(), input.Username, input.Password)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                Username string `json:"username"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.uc.Login(r.Context(), input.Username, input.Password)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                RefreshToken string `json:"refresh_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.uc.RefreshTokens(r.Context(), input.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid refresh token", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(w).Encode(tokens)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package entities

import "time"

type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
}

// AccessToken представляет токен доступа
type AccessToken struct {
        ID        int64     `json:"id"`
        UserID    int64     `json:"user_id"`
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
}

// Методы для проверки состояния access токена
func (at *AccessToken) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(at.ExpiresAt)
}</span>

func (at *AccessToken) IsValid() bool <span class="cov0" title="0">{
        return !at.IsExpired()
}</span>

type TokenClaims struct {
        UserID    int64  `json:"user_id"`
        Username  string `json:"username"`
        IsAdmin   bool   `json:"is_admin"`
        ExpiresAt int64  `json:"exp"`
        IssuedAt  int64  `json:"iat"`
        TokenType string `json:"typ"`
}

// RefreshToken представляет токен обновления в базе данных
type RefreshToken struct {
        ID        int64     `json:"id"`
        UserID    int64     `json:"user_id"`
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
        Revoked   bool      `json:"revoked"`
}

// Методы для проверки состояния refresh токена
func (rt *RefreshToken) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(rt.ExpiresAt)
}</span>

func (rt *RefreshToken) IsValid() bool <span class="cov0" title="0">{
        return !rt.Revoked &amp;&amp; !rt.IsExpired()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package entities

import (
        "errors"
        "time"
)

type User struct {
        ID           int64     `json:"id"`
        Username     string    `json:"username"`
        PasswordHash string    `json:"-"` // Изменено с Password на PasswordHash для безопасности
        CreatedAt    time.Time `json:"created_at"`
        IsAdmin      bool      `json:"is_admin"`   // Добавлено для контроля прав
        UpdatedAt    time.Time `json:"updated_at"` // Добавлено для аудита
}

type SafeUser struct {
        ID        int64     `json:"id"`
        Username  string    `json:"username"`
        CreatedAt time.Time `json:"created_at"`
        IsAdmin   bool      `json:"is_admin"`
}

// ToSafe конвертирует User в SafeUser, скрывая чувствительные данные
func (u *User) ToSafe() *SafeUser <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;SafeUser{
                ID:        u.ID,
                Username:  u.Username,
                CreatedAt: u.CreatedAt,
                IsAdmin:   u.IsAdmin,
        }</span>
}

// Validate проверяет корректность данных пользователя
func (u *User) Validate() error <span class="cov0" title="0">{
        if u.Username == "" </span><span class="cov0" title="0">{
                return errors.New("username cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(u.Username) &lt; 3 || len(u.Username) &gt; 50 </span><span class="cov0" title="0">{
                return errors.New("username must be between 3 and 50 characters")
        }</span>
        <span class="cov0" title="0">if len(u.PasswordHash) == 0 </span><span class="cov0" title="0">{
                return errors.New("password hash cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BeforeCreate подготавливает пользователя к созданию
func (u *User) BeforeCreate() <span class="cov0" title="0">{
        now := time.Now()
        u.CreatedAt = now
        u.UpdatedAt = now
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "context"

        "github.com/jackc/pgx/v5"
)

func NewPostgresConnection(connStr string) (*pgx.Conn, error) <span class="cov0" title="0">{
        return pgx.Connect(context.Background(), connStr)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// repository/auth.go
package repository

import (
        "back/auth_service/internal/entities"
        "back/pkg/errors"
        "back/pkg/logger"
        "context"
        "database/sql"
        "fmt"
)

// UserRepository определяет методы для работы с пользователями в БД
type UserRepository interface {
        Create(ctx context.Context, user *entities.User) error
        GetByID(ctx context.Context, id int64) (*entities.User, error)
        GetByUsername(ctx context.Context, username string) (*entities.User, error)
        UpdateUsername(ctx context.Context, id int64, newName string) error
        Delete(ctx context.Context, id int64) error
        IsAdmin(ctx context.Context, userID int64) (bool, error)
}

// TokenRepository определяет методы для работы с refresh токенами в БД
type TokenRepository interface {
        Create(ctx context.Context, token *entities.RefreshToken) error
        GetByToken(ctx context.Context, token string) (*entities.RefreshToken, error)
        Revoke(ctx context.Context, token string) error
        DeleteExpired(ctx context.Context) error
        RevokeAllUserTokens(ctx context.Context, userID int64) error
}

// Реализация для PostgreSQL
type userRepo struct {
        db  *sql.DB
        log logger.Logger // Используем интерфейс из пакета logger
}

type tokenRepo struct {
        db  *sql.DB
        log logger.Logger // Используем интерфейс из пакета logger
}

func (r *userRepo) Create(ctx context.Context, user *entities.User) error <span class="cov0" title="0">{ // Изменен возвращаемый тип
        query := `
        INSERT INTO users (username, password_hash, created_at)
        VALUES ($1, $2, CURRENT_TIMESTAMP)
        RETURNING id`

        r.log.Info("creating user",
                logger.NewField("username", user.Username),
        )

        err := r.db.QueryRowContext(ctx, query,
                user.Username, user.PasswordHash,
        ).Scan(&amp;user.ID)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create user",
                        logger.NewField("error", err),
                        logger.NewField("username", user.Username),
                )
                return fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *userRepo) GetByID(ctx context.Context, id int64) (*entities.User, error) <span class="cov0" title="0">{
        user := &amp;entities.User{}
        query := `
        SELECT id, username, password_hash, created_at 
        FROM users 
        WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.PasswordHash, &amp;user.CreatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrUserNotFound
        }</span>
        <span class="cov0" title="0">return user, err</span>
}

func (r *userRepo) GetByUsername(ctx context.Context, username string) (*entities.User, error) <span class="cov0" title="0">{
        user := &amp;entities.User{}
        query := `
        SELECT id, username, password_hash, created_at 
        FROM users 
        WHERE username = $1`
        err := r.db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.PasswordHash, &amp;user.CreatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrUserNotFound
        }</span>
        <span class="cov0" title="0">return user, err</span>
}

func (r *userRepo) UpdateUsername(ctx context.Context, id int64, newName string) error <span class="cov0" title="0">{ // Изменен возвращаемый тип
        query := `UPDATE users SET username = $1 WHERE id = $2`

        r.log.Info("updating username",
                logger.NewField("user_id", id),
                logger.NewField("new_name", newName),
        )

        result, err := r.db.ExecContext(ctx, query, newName, id) // Используем ExecContext вместо QueryContext
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to update username",
                        logger.NewField("error", err),
                        logger.NewField("user_id", id),
                )
                return fmt.Errorf("update username: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *userRepo) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return errors.ErrDeleteFailed
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (r *userRepo) IsAdmin(ctx context.Context, userID int64) (bool, error) <span class="cov0" title="0">{
        var isAdmin bool
        query := `SELECT is_admin FROM users WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, userID).Scan(&amp;isAdmin)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return false, errors.ErrUserNotFound
        }</span>
        <span class="cov0" title="0">return isAdmin, err</span>
}

func NewUserRepository(db *sql.DB, logger logger.Logger) UserRepository <span class="cov0" title="0">{
        return &amp;userRepo{
                db:  db,
                log: logger,
        }
}</span>

func NewTokenRepository(db *sql.DB, logger logger.Logger) TokenRepository <span class="cov0" title="0">{
        return &amp;tokenRepo{
                db:  db,
                log: logger,
        }
}</span>

func (r *tokenRepo) Create(ctx context.Context, token *entities.RefreshToken) error <span class="cov0" title="0">{
        query := `
        INSERT INTO refresh_tokens (user_id, token, expires_at)
        VALUES ($1, $2, $3)`
        _, err := r.db.ExecContext(ctx, query,
                token.UserID, token.Token, token.ExpiresAt,
        )
        return err
}</span>

func (r *tokenRepo) GetByToken(ctx context.Context, token string) (*entities.RefreshToken, error) <span class="cov0" title="0">{
        rt := &amp;entities.RefreshToken{}
        query := `
        SELECT id, user_id, token, expires_at, created_at 
        FROM refresh_tokens 
        WHERE token = $1`

        r.log.Info("getting refresh token",
                logger.NewField("token", token),
        )

        err := r.db.QueryRowContext(ctx, query, token).Scan(
                &amp;rt.ID, &amp;rt.UserID, &amp;rt.Token, &amp;rt.ExpiresAt, &amp;rt.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenNotFound
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to get refresh token",
                        logger.NewField("error", err),
                        logger.NewField("token", token),
                )
                return nil, fmt.Errorf("get refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return rt, nil</span>
}

func (r *tokenRepo) Revoke(ctx context.Context, token string) error <span class="cov0" title="0">{
        query := `DELETE FROM refresh_tokens WHERE token = $1`
        _, err := r.db.ExecContext(ctx, query, token)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to revoke token",
                        logger.NewField("error", err),
                        logger.NewField("token", token),
                )
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (r *tokenRepo) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        query := `DELETE FROM refresh_tokens WHERE expires_at &lt; NOW()`
        _, err := r.db.ExecContext(ctx, query)
        return err
}</span>

func (r *tokenRepo) RevokeAllUserTokens(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        query := `DELETE FROM refresh_tokens WHERE user_id = $1`
        _, err := r.db.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to revoke user tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: auth_service/internal/service/token_service.go
//
// Generated by this command:
//
//        mockgen -source=auth_service/internal/service/token_service.go -destination=auth_service/internal/service/mocks/token_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "back/auth_service/internal/entities"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockTokenServiceInterface is a mock of TokenServiceInterface interface.
type MockTokenServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockTokenServiceInterfaceMockRecorder
        isgomock struct{}
}

// MockTokenServiceInterfaceMockRecorder is the mock recorder for MockTokenServiceInterface.
type MockTokenServiceInterfaceMockRecorder struct {
        mock *MockTokenServiceInterface
}

// NewMockTokenServiceInterface creates a new mock instance.
func NewMockTokenServiceInterface(ctrl *gomock.Controller) *MockTokenServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockTokenServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockTokenServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenServiceInterface) EXPECT() *MockTokenServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GenerateTokenPair mocks base method.
func (m *MockTokenServiceInterface) GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateTokenPair", userID, username, isAdmin)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GenerateTokenPair indicates an expected call of GenerateTokenPair.
func (mr *MockTokenServiceInterfaceMockRecorder) GenerateTokenPair(userID, username, isAdmin any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateTokenPair", reflect.TypeOf((*MockTokenServiceInterface)(nil).GenerateTokenPair), userID, username, isAdmin)
}</span>

// ValidateToken mocks base method.
func (m *MockTokenServiceInterface) ValidateToken(tokenString string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateToken", tokenString)
        ret0, _ := ret[0].(*entities.TokenClaims)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ValidateToken indicates an expected call of ValidateToken.
func (mr *MockTokenServiceInterfaceMockRecorder) ValidateToken(tokenString any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateToken", reflect.TypeOf((*MockTokenServiceInterface)(nil).ValidateToken), tokenString)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "back/auth_service/internal/entities"
        "back/pkg/logger"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt"
)

const (
        AccessTokenType  = "access"
        RefreshTokenType = "refresh"
)

type TokenService struct {
        secretKey       string
        AccessTokenTTL  time.Duration
        RefreshTokenTTL time.Duration
        logger          logger.Logger
}

type TokenServiceInterface interface {
        GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error)
        ValidateToken(tokenString string) (*entities.TokenClaims, error)
}

func NewTokenService(secretKey string, accessTTL, refreshTTL time.Duration, logger logger.Logger) *TokenService <span class="cov0" title="0">{
        return &amp;TokenService{
                secretKey:       secretKey,
                AccessTokenTTL:  accessTTL,
                RefreshTokenTTL: refreshTTL,
                logger:          logger,
        }
}</span>

func (s *TokenService) GenerateTokenPair(userID int64, username string, isAdmin bool) (*entities.TokenPair, error) <span class="cov0" title="0">{
        s.logger.Info("generating token pair",
                logger.NewField("user_id", userID),
                logger.NewField("username", username),
        )

        // Генерируем Access Token
        accessToken, err := s.generateToken(userID, username, isAdmin, s.AccessTokenTTL, AccessTokenType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to generate access token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        // Генерируем Refresh Token
        <span class="cov0" title="0">refreshToken, err := s.generateToken(userID, username, isAdmin, s.RefreshTokenTTL, RefreshTokenType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to generate refresh token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(s.AccessTokenTTL)

        return &amp;entities.TokenPair{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresAt:    expiresAt,
        }, nil</span>
}

func (s *TokenService) ValidateToken(tokenString string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        if tokenString == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty token")
        }</span>

        <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(s.secretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(*jwt.ValidationError); ok </span><span class="cov0" title="0">{
                        if ve.Errors&amp;jwt.ValidationErrorExpired != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("token expired")
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to parse token: %w", err)</span>
        }

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov0" title="0">userID, ok := claims["user_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user_id claim")
        }</span>

        <span class="cov0" title="0">username, ok := claims["username"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username claim")
        }</span>

        <span class="cov0" title="0">isAdmin, ok := claims["is_admin"].(bool)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid is_admin claim")
        }</span>

        <span class="cov0" title="0">tokenType, ok := claims["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token type claim")
        }</span>

        <span class="cov0" title="0">return &amp;entities.TokenClaims{
                UserID:    int64(userID),
                Username:  username,
                IsAdmin:   isAdmin,
                ExpiresAt: int64(claims["exp"].(float64)),
                TokenType: tokenType,
        }, nil</span>
}

func (s *TokenService) generateToken(userID int64, username string, isAdmin bool, expiration time.Duration, tokenType string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := jwt.MapClaims{
                "user_id":  userID,
                "username": username,
                "is_admin": isAdmin,
                "type":     tokenType,
                "iat":      now.Unix(),
                "exp":      now.Add(expiration).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        signedToken, err := token.SignedString([]byte(s.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov0" title="0">return signedToken, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "back/auth_service/internal/entities"
        "back/auth_service/internal/repository"
        "back/auth_service/internal/service"
        "back/pkg/errors"
        "back/pkg/logger"
        "context"
        "time"

        "golang.org/x/crypto/bcrypt"
)

type AuthUsecaseInterface interface {
        Register(ctx context.Context, username, password string) (*entities.TokenPair, error)
        Login(ctx context.Context, username, password string) (*entities.TokenPair, error)
        RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error)
        IsAdmin(ctx context.Context, userID int64) (bool, error)
        RevokeTokens(ctx context.Context, userID int64) error
        Logout(ctx context.Context, refreshToken string) error
        ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error)
}

type AuthUsecase struct {
        userRepo        repository.UserRepository
        tokenRepo       repository.TokenRepository
        tokenService    service.TokenServiceInterface
        logger          logger.Logger
        RefreshTokenTTL time.Duration
}

func NewAuthUsecase(userRepo repository.UserRepository, tokenRepo repository.TokenRepository, tokenService service.TokenServiceInterface, logger logger.Logger) *AuthUsecase <span class="cov8" title="1">{
        return &amp;AuthUsecase{
                userRepo:        userRepo,
                tokenRepo:       tokenRepo,
                tokenService:    tokenService,
                logger:          logger,
                RefreshTokenTTL: time.Hour * 24 * 30, // 30 days
        }
}</span>

func (uc *AuthUsecase) Login(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        uc.logger.Info("attempting login",
                logger.NewField("username", username),
        )

        user, err := uc.userRepo.GetByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to get user",
                        logger.NewField("error", err),
                        logger.NewField("username", username),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">if !CheckPasswordHash(password, user.PasswordHash) </span><span class="cov0" title="0">{
                uc.logger.Warn("invalid password attempt",
                        logger.NewField("username", username),
                )
                return nil, errors.ErrWrongPassword
        }</span>

        <span class="cov0" title="0">tokens, err := uc.tokenService.GenerateTokenPair(user.ID, user.Username, user.IsAdmin)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to generate tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    user.ID,
                Token:     tokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to save refresh token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">uc.logger.Info("login successful",
                logger.NewField("user_id", user.ID),
                logger.NewField("username", username),
        )

        return tokens, nil</span>
}

func (uc *AuthUsecase) RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        // Валидируем refresh token
        claims, err := uc.tokenService.ValidateToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenInvalid
        }</span>

        // Проверяем токен в базе
        <span class="cov0" title="0">dbToken, err := uc.tokenRepo.GetByToken(ctx, refreshToken)
        if err != nil || dbToken.Revoked || time.Now().After(dbToken.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, errors.ErrTokenInvalid
        }</span>

        // Генерируем новую пару токенов
        <span class="cov0" title="0">newTokens, err := uc.tokenService.GenerateTokenPair(claims.UserID, claims.Username, claims.IsAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Отзываем старый refresh token
        <span class="cov0" title="0">if err := uc.tokenRepo.Revoke(ctx, refreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Сохраняем новый refresh token
        <span class="cov0" title="0">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    claims.UserID,
                Token:     newTokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return newTokens, nil</span>
}

func (uc *AuthUsecase) Register(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov8" title="1">{
        uc.logger.Info("attempting registration",
                logger.NewField("username", username),
        )

        // Валидация входных данных
        if err := validateCredentials(username, password); err != nil </span><span class="cov0" title="0">{
                uc.logger.Warn("invalid credentials provided",
                        logger.NewField("error", err),
                        logger.NewField("username", username),
                )
                return nil, err
        }</span>

        // Проверяем, не существует ли пользователь
        <span class="cov8" title="1">_, err := uc.userRepo.GetByUsername(ctx, username)
        if err == nil </span><span class="cov0" title="0">{
                uc.logger.Warn("user already exists",
                        logger.NewField("username", username),
                )
                return nil, errors.ErrDuplicateUsername
        }</span>

        // Хешируем пароль
        <span class="cov8" title="1">passwordHash, err := HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to hash password",
                        logger.NewField("error", err),
                )
                return nil, err
        }</span>

        // Создаем пользователя
        <span class="cov8" title="1">user := &amp;entities.User{
                Username:     username,
                PasswordHash: passwordHash,
                CreatedAt:    time.Now(),
        }

        err = uc.userRepo.Create(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to create user",
                        logger.NewField("error", err),
                        logger.NewField("username", username),
                )
                return nil, err
        }</span>

        // Генерируем токены
        <span class="cov8" title="1">tokens, err := uc.tokenService.GenerateTokenPair(user.ID, user.Username, user.IsAdmin)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to generate tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        // Сохраняем refresh token
        <span class="cov8" title="1">if err := uc.tokenRepo.Create(ctx, &amp;entities.RefreshToken{
                UserID:    user.ID,
                Token:     tokens.RefreshToken,
                ExpiresAt: time.Now().Add(uc.RefreshTokenTTL),
        }); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to save refresh token",
                        logger.NewField("error", err),
                        logger.NewField("user_id", user.ID),
                )
                return nil, err
        }</span>

        <span class="cov8" title="1">uc.logger.Info("registration successful",
                logger.NewField("user_id", user.ID),
                logger.NewField("username", username),
        )

        return tokens, nil</span>
}

func (uc *AuthUsecase) IsAdmin(ctx context.Context, userID int64) (bool, error) <span class="cov0" title="0">{
        user, err := uc.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return user.IsAdmin, nil</span>
}

func (uc *AuthUsecase) RevokeTokens(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        uc.logger.Info("attempting to revoke all user tokens",
                logger.NewField("user_id", userID),
        )

        if err := uc.tokenRepo.RevokeAllUserTokens(ctx, userID); err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("failed to revoke user tokens",
                        logger.NewField("error", err),
                        logger.NewField("user_id", userID),
                )
                return err
        }</span>

        <span class="cov0" title="0">uc.logger.Info("successfully revoked all user tokens",
                logger.NewField("user_id", userID),
        )

        return nil</span>
}

func (uc *AuthUsecase) Logout(ctx context.Context, refreshToken string) error <span class="cov0" title="0">{
        return uc.tokenRepo.Revoke(ctx, refreshToken)
}</span>

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func validateCredentials(username, password string) error <span class="cov8" title="1">{
        if len(username) &lt; 3 </span><span class="cov0" title="0">{
                return errors.ErrUsernameTooShort
        }</span>
        <span class="cov8" title="1">if len(username) &gt; 50 </span><span class="cov0" title="0">{
                return errors.ErrUsernameTooLong
        }</span>
        <span class="cov8" title="1">if len(password) &lt; 4 </span><span class="cov0" title="0">{
                return errors.ErrWeakPassword
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (a *AuthUsecase) ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        claims, err := a.tokenService.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: auth_service/internal/usecase/auth.go
//
// Generated by this command:
//
//        mockgen -source=auth_service/internal/usecase/auth.go -destination=auth_service/internal/usecase/mocks/repo_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "back/auth_service/internal/entities"
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockAuthUsecaseInterface is a mock of AuthUsecaseInterface interface.
type MockAuthUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockAuthUsecaseInterfaceMockRecorder
        isgomock struct{}
}

// MockAuthUsecaseInterfaceMockRecorder is the mock recorder for MockAuthUsecaseInterface.
type MockAuthUsecaseInterfaceMockRecorder struct {
        mock *MockAuthUsecaseInterface
}

// NewMockAuthUsecaseInterface creates a new mock instance.
func NewMockAuthUsecaseInterface(ctrl *gomock.Controller) *MockAuthUsecaseInterface <span class="cov0" title="0">{
        mock := &amp;MockAuthUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockAuthUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthUsecaseInterface) EXPECT() *MockAuthUsecaseInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// IsAdmin mocks base method.
func (m *MockAuthUsecaseInterface) IsAdmin(ctx context.Context, userID int64) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsAdmin", ctx, userID)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsAdmin indicates an expected call of IsAdmin.
func (mr *MockAuthUsecaseInterfaceMockRecorder) IsAdmin(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAdmin", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).IsAdmin), ctx, userID)
}</span>

// Login mocks base method.
func (m *MockAuthUsecaseInterface) Login(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", ctx, username, password)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Login(ctx, username, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Login), ctx, username, password)
}</span>

// Logout mocks base method.
func (m *MockAuthUsecaseInterface) Logout(ctx context.Context, refreshToken string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logout", ctx, refreshToken)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Logout indicates an expected call of Logout.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Logout(ctx, refreshToken any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Logout), ctx, refreshToken)
}</span>

// RefreshTokens mocks base method.
func (m *MockAuthUsecaseInterface) RefreshTokens(ctx context.Context, refreshToken string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RefreshTokens", ctx, refreshToken)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// RefreshTokens indicates an expected call of RefreshTokens.
func (mr *MockAuthUsecaseInterfaceMockRecorder) RefreshTokens(ctx, refreshToken any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokens", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).RefreshTokens), ctx, refreshToken)
}</span>

// Register mocks base method.
func (m *MockAuthUsecaseInterface) Register(ctx context.Context, username, password string) (*entities.TokenPair, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", ctx, username, password)
        ret0, _ := ret[0].(*entities.TokenPair)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockAuthUsecaseInterfaceMockRecorder) Register(ctx, username, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).Register), ctx, username, password)
}</span>

// RevokeTokens mocks base method.
func (m *MockAuthUsecaseInterface) RevokeTokens(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RevokeTokens", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RevokeTokens indicates an expected call of RevokeTokens.
func (mr *MockAuthUsecaseInterfaceMockRecorder) RevokeTokens(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeTokens", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).RevokeTokens), ctx, userID)
}</span>

// ValidateToken mocks base method.
func (m *MockAuthUsecaseInterface) ValidateToken(ctx context.Context, token string) (*entities.TokenClaims, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateToken", ctx, token)
        ret0, _ := ret[0].(*entities.TokenClaims)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ValidateToken indicates an expected call of ValidateToken.
func (mr *MockAuthUsecaseInterfaceMockRecorder) ValidateToken(ctx, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateToken", reflect.TypeOf((*MockAuthUsecaseInterface)(nil).ValidateToken), ctx, token)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "database/sql"
        "fmt"
        "io/fs"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"

        _ "github.com/lib/pq"
)

func main() <span class="cov0" title="0">{
        dsn := "postgres://postgres:1@localhost:5555/forum?sslmode=disable"

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка подключения к базе: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        migrationsDir := "./migrations/migrations/up"

        files, err := os.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка чтения директории миграций: %v", err)
        }</span>

        <span class="cov0" title="0">var sqlFiles []fs.DirEntry
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                        sqlFiles = append(sqlFiles, file)
                }</span>
        }

        <span class="cov0" title="0">sort.Slice(sqlFiles, func(i, j int) bool </span><span class="cov0" title="0">{
                return sqlFiles[i].Name() &lt; sqlFiles[j].Name()
        }</span>)

        <span class="cov0" title="0">for _, file := range sqlFiles </span><span class="cov0" title="0">{
                path := filepath.Join(migrationsDir, file.Name())
                content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Ошибка чтения %s: %v", path, err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Выполнение миграции: %s\n", file.Name())
                if _, err := db.Exec(string(content)); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Ошибка выполнения миграции %s: %v", file.Name(), err)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Все миграции успешно применены.")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        pb "back/proto"
        "net/http"

        "github.com/gin-gonic/gin"
)

func authMiddleware(authClient pb.AuthServiceClient) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 1. Получаем access token из заголовка Authorization
                token := c.GetHeader("Authorization")
                if token == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "токен не найден"})
                        return
                }</span>

                // 2. Удаляем префикс "Bearer "
                <span class="cov0" title="0">if len(token) &gt; 7 &amp;&amp; token[:7] == "Bearer " </span><span class="cov0" title="0">{
                        token = token[7:]
                }</span>

                // 3. Валидируем токен через gRPC Auth-сервис
                <span class="cov0" title="0">resp, err := authClient.ValidateToken(c.Request.Context(), &amp;pb.ValidateRequest{
                        AccessToken: token,
                })
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "недействительный токен"})
                        return
                }</span>

                // 4. Сохраняем userID и username в контекст
                <span class="cov0" title="0">c.Set("userID", resp.UserId)
                c.Set("username", resp.Username)
                c.Set("isAdmin", resp.IsAdmin)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// forum_service/internal/delivery/ws/chat.go
package ws

import (
        "back/forum_service/internal/entities"
        "back/forum_service/internal/usecase"
        "back/pkg/logger"
        pb "back/proto"
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

type ChatHandler struct {
        upgrader websocket.Upgrader
        clients  sync.Map
        chatUC   *usecase.ChatUsecase
        logger   logger.Logger
        config   *pb.ChatConfig
}

func NewChatHandler(chatUC *usecase.ChatUsecase, logger logger.Logger, config *pb.ChatConfig) *ChatHandler <span class="cov0" title="0">{
        return &amp;ChatHandler{
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true // Разрешаем все подключения для учебного проекта
                        }</span>,
                },
                clients: sync.Map{},
                chatUC:  chatUC,
                logger:  logger,
                config:  config,
        }
}

// HandleWebSocket обрабатывает WebSocket соединения
func (h *ChatHandler) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Получаем ID пользователя из токена (для учебного проекта можно хардкодить)
        userID := int64(1) // Для теста

        conn, err := h.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("ошибка подключения websocket",
                        logger.NewField("error", err))
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Добавляем клиента
        h.clients.Store(conn, true)
        defer h.clients.Delete(conn)

        // Чтение сообщений
        for </span><span class="cov0" title="0">{
                var msg entities.ChatMessage
                if err := conn.ReadJSON(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        break</span> // Клиент отключился
                }

                <span class="cov0" title="0">msg.UserID = userID
                msg.CreatedAt = time.Now()

                // Сохраняем и рассылаем сообщение
                if err := h.handleMessage(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("ошибка обработки сообщения",
                                logger.NewField("error", err))
                }</span>
        }
}

// handleMessage обрабатывает новое сообщение
func (h *ChatHandler) handleMessage(msg *entities.ChatMessage) error <span class="cov0" title="0">{
        if msg.Content == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("пустое сообщение")
        }</span>

        // Сохраняем
        <span class="cov0" title="0">ctx := context.Background()
        if err := h.chatUC.SendMessage(ctx, msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Рассылаем всем
        <span class="cov0" title="0">h.broadcast(msg)
        return nil</span>
}

// broadcast рассылает сообщение всем подключенным клиентам
func (h *ChatHandler) broadcast(msg *entities.ChatMessage) <span class="cov0" title="0">{
        h.clients.Range(func(key, _ interface{}) bool </span><span class="cov0" title="0">{
                client := key.(*websocket.Conn)
                if err := client.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                        client.Close()
                        h.clients.Delete(client)
                }</span>
                <span class="cov0" title="0">return true</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "back/forum_service/internal/entities"
        e "back/pkg/errors"
        "back/pkg/logger"
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"
)

const (
        DefaultMessagesLimit = 100
        DefaultPostsLimit    = 20
)

const (
        TargetTypePost    = "post"
        TargetTypeComment = "comment"
)

type ChatRepository interface {
        SaveMessage(ctx context.Context, userID int64, content string) error
        DeleteOldMessages(ctx context.Context, before time.Time) error
        GetMessages(ctx context.Context) ([]*entities.ChatMessage, error)
}

type PostRepository interface {
        CreatePost(ctx context.Context, post *entities.Post) error
        GetPostByID(ctx context.Context, id int64) (*entities.Post, error)
        UpdatePost(ctx context.Context, post *entities.Post) error
        DeletePost(ctx context.Context, id int64) error
        Posts(ctx context.Context) ([]*entities.Post, error)
}

type CommentRepository interface {
        CreateComment(ctx context.Context, comment *entities.Comment) error
        GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error)
        GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error)
        GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error)
        UpdateComment(ctx context.Context, comment *entities.Comment) error
        DeleteComment(ctx context.Context, id int64) error
}

type Db struct {
        db     *sql.DB
        logger logger.Logger
}

func NewPostRepository(db *sql.DB, log logger.Logger) PostRepository <span class="cov8" title="1">{
        return &amp;Db{db: db, logger: log}
}</span>

func NewCommentRepository(db *sql.DB, log logger.Logger) CommentRepository <span class="cov8" title="1">{
        return &amp;Db{db: db, logger: log}
}</span>

func NewChatRepository(db *sql.DB, log logger.Logger) ChatRepository <span class="cov8" title="1">{
        return &amp;Db{db: db, logger: log}
}</span>

// --- Post Repository ---

func (r *Db) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        query := `
                INSERT INTO posts (title, content, author_id, created_at)
                VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
                RETURNING id, created_at`
        return r.db.QueryRowContext(ctx, query, post.Title, post.Content, post.AuthorID).
                Scan(&amp;post.ID, &amp;post.CreatedAt)
}</span>

func (r *Db) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov8" title="1">{
        query := `
                SELECT id, title, content, author_id, created_at, updated_at,
                        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
                FROM posts p WHERE id = $1`

        post := &amp;entities.Post{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;post.ID, &amp;post.Title, &amp;post.Content, &amp;post.AuthorID,
                &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.CommentCount,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("получение поста: %w", err)
        }</span>
        <span class="cov8" title="1">return post, nil</span>
}

func (r *Db) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        query := `UPDATE posts SET title = $1, content = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3`
        _, err := r.db.ExecContext(ctx, query, post.Title, post.Content, post.ID)
        return err
}</span>

func (r *Db) DeletePost(ctx context.Context, id int64) error <span class="cov8" title="1">{
        query := `DELETE FROM posts WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>

func (r *Db) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov8" title="1">{
        query := `
                SELECT id, title, content, author_id, created_at, updated_at,
                        (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
                FROM posts p ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("получение постов: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var posts []*entities.Post
        for rows.Next() </span><span class="cov8" title="1">{
                post := &amp;entities.Post{}
                err := rows.Scan(
                        &amp;post.ID, &amp;post.Title, &amp;post.Content, &amp;post.AuthorID,
                        &amp;post.CreatedAt, &amp;post.UpdatedAt, &amp;post.CommentCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка сканирования поста: %w", err)
                }</span>
                <span class="cov8" title="1">posts = append(posts, post)</span>
        }
        <span class="cov8" title="1">return posts, nil</span>
}

// --- Chat Repository ---

func (r *Db) SaveMessage(ctx context.Context, userID int64, content string) error <span class="cov8" title="1">{
        var id int64
        query := `INSERT INTO chat_messages (user_id, content, created_at) VALUES ($1, $2, NOW()) RETURNING id`
        return r.db.QueryRowContext(ctx, query, userID, content).Scan(&amp;id)
}</span>

func (r *Db) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov8" title="1">{
        query := `DELETE FROM chat_messages WHERE created_at &lt; $1`

        result, err := r.db.ExecContext(ctx, query, before)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("ошибка удаления старых сообщений", logger.NewField("error", err))
                return err
        }</span>

        <span class="cov8" title="1">affected, _ := result.RowsAffected()
        r.logger.Info("удалены старые сообщения",
                logger.NewField("count", affected),
                logger.NewField("older_than", before))

        return nil</span>
}

func (r *Db) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov8" title="1">{
        query := `
                SELECT cm.id, cm.user_id, cm.content, cm.created_at, u.username
                FROM chat_messages cm
                JOIN users u ON cm.user_id = u.id
                ORDER BY cm.created_at DESC
                `
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка получения сообщений: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var messages []*entities.ChatMessage
        for rows.Next() </span><span class="cov8" title="1">{
                msg := &amp;entities.ChatMessage{}
                err := rows.Scan(&amp;msg.ID, &amp;msg.UserID, &amp;msg.Content, &amp;msg.CreatedAt, &amp;msg.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка сканирования сообщения: %w", err)
                }</span>
                <span class="cov8" title="1">messages = append(messages, msg)</span>
        }
        <span class="cov8" title="1">return messages, nil</span>
}

// ----------------------- CommentRepository

func (r *Db) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        query := `
        INSERT INTO comments (post_id, author_id, content, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
    `
        now := time.Now()
        comment.CreatedAt = now
        comment.UpdatedAt = nil // new comment, no update yet

        return r.db.QueryRowContext(
                ctx,
                query,
                comment.PostID,
                comment.AuthorID,
                comment.Content,
                comment.CreatedAt,
                comment.UpdatedAt,
        ).Scan(&amp;comment.ID)
}</span>

func (r *Db) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov8" title="1">{
        query := `
        SELECT id, post_id, author_id, content, created_at, updated_at
        FROM comments
        WHERE id = $1
    `
        row := r.db.QueryRowContext(ctx, query, id)

        var comment entities.Comment
        err := row.Scan(
                &amp;comment.ID,
                &amp;comment.PostID,
                &amp;comment.AuthorID,
                &amp;comment.Content,
                &amp;comment.CreatedAt,
                &amp;comment.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, e.ErrCommentNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;comment, nil</span>
}

func (r *Db) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        query := `
        SELECT id, post_id, author_id, content, created_at, updated_at
        FROM comments
        WHERE post_id = $1
        ORDER BY created_at ASC
    `
        rows, err := r.db.QueryContext(ctx, query, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var comments []*entities.Comment
        for rows.Next() </span><span class="cov8" title="1">{
                var comment entities.Comment
                if err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.PostID,
                        &amp;comment.AuthorID,
                        &amp;comment.Content,
                        &amp;comment.CreatedAt,
                        &amp;comment.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">comments = append(comments, &amp;comment)</span>
        }

        <span class="cov8" title="1">return comments, nil</span>
}

func (r *Db) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        query := `
        SELECT id, post_id, author_id, content, created_at, updated_at
        FROM comments
        WHERE author_id = $1
        ORDER BY created_at DESC
    `
        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var comments []*entities.Comment
        for rows.Next() </span><span class="cov8" title="1">{
                var comment entities.Comment
                if err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.PostID,
                        &amp;comment.AuthorID,
                        &amp;comment.Content,
                        &amp;comment.CreatedAt,
                        &amp;comment.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">comments = append(comments, &amp;comment)</span>
        }

        <span class="cov8" title="1">return comments, nil</span>
}

func (r *Db) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        now := time.Now()
        comment.UpdatedAt = &amp;now

        query := `
        UPDATE comments
        SET content = $1, updated_at = $2
        WHERE id = $3
    `
        res, err := r.db.ExecContext(ctx, query, comment.Content, comment.UpdatedAt, comment.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no comment found with id %d", comment.ID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Db) DeleteComment(ctx context.Context, id int64) error <span class="cov8" title="1">{
        query := `DELETE FROM comments WHERE id = $1`
        res, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">affected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if affected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no comment found with id %d", id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/repository/forum.go
//
// Generated by this command:
//
//        mockgen -source=forum_service/internal/repository/forum.go -destination=forum_service/internal/repository/mocks/repo_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "back/forum_service/internal/entities"
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockChatRepository is a mock of ChatRepository interface.
type MockChatRepository struct {
        ctrl     *gomock.Controller
        recorder *MockChatRepositoryMockRecorder
        isgomock struct{}
}

// MockChatRepositoryMockRecorder is the mock recorder for MockChatRepository.
type MockChatRepositoryMockRecorder struct {
        mock *MockChatRepository
}

// NewMockChatRepository creates a new mock instance.
func NewMockChatRepository(ctrl *gomock.Controller) *MockChatRepository <span class="cov0" title="0">{
        mock := &amp;MockChatRepository{ctrl: ctrl}
        mock.recorder = &amp;MockChatRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatRepository) EXPECT() *MockChatRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DeleteOldMessages mocks base method.
func (m *MockChatRepository) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteOldMessages", ctx, before)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteOldMessages indicates an expected call of DeleteOldMessages.
func (mr *MockChatRepositoryMockRecorder) DeleteOldMessages(ctx, before any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOldMessages", reflect.TypeOf((*MockChatRepository)(nil).DeleteOldMessages), ctx, before)
}</span>

// GetMessages mocks base method.
func (m *MockChatRepository) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMessages", ctx)
        ret0, _ := ret[0].([]*entities.ChatMessage)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMessages indicates an expected call of GetMessages.
func (mr *MockChatRepositoryMockRecorder) GetMessages(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessages", reflect.TypeOf((*MockChatRepository)(nil).GetMessages), ctx)
}</span>

// SaveMessage mocks base method.
func (m *MockChatRepository) SaveMessage(ctx context.Context, userID int64, content string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SaveMessage", ctx, userID, content)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SaveMessage indicates an expected call of SaveMessage.
func (mr *MockChatRepositoryMockRecorder) SaveMessage(ctx, userID, content any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveMessage", reflect.TypeOf((*MockChatRepository)(nil).SaveMessage), ctx, userID, content)
}</span>

// MockPostRepository is a mock of PostRepository interface.
type MockPostRepository struct {
        ctrl     *gomock.Controller
        recorder *MockPostRepositoryMockRecorder
        isgomock struct{}
}

// MockPostRepositoryMockRecorder is the mock recorder for MockPostRepository.
type MockPostRepositoryMockRecorder struct {
        mock *MockPostRepository
}

// NewMockPostRepository creates a new mock instance.
func NewMockPostRepository(ctrl *gomock.Controller) *MockPostRepository <span class="cov8" title="1">{
        mock := &amp;MockPostRepository{ctrl: ctrl}
        mock.recorder = &amp;MockPostRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPostRepository) EXPECT() *MockPostRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreatePost mocks base method.
func (m *MockPostRepository) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePost", ctx, post)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreatePost indicates an expected call of CreatePost.
func (mr *MockPostRepositoryMockRecorder) CreatePost(ctx, post any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePost", reflect.TypeOf((*MockPostRepository)(nil).CreatePost), ctx, post)
}</span>

// DeletePost mocks base method.
func (m *MockPostRepository) DeletePost(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeletePost", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeletePost indicates an expected call of DeletePost.
func (mr *MockPostRepositoryMockRecorder) DeletePost(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePost", reflect.TypeOf((*MockPostRepository)(nil).DeletePost), ctx, id)
}</span>

// GetPostByID mocks base method.
func (m *MockPostRepository) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPostByID", ctx, id)
        ret0, _ := ret[0].(*entities.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPostByID indicates an expected call of GetPostByID.
func (mr *MockPostRepositoryMockRecorder) GetPostByID(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPostByID", reflect.TypeOf((*MockPostRepository)(nil).GetPostByID), ctx, id)
}</span>

// Posts mocks base method.
func (m *MockPostRepository) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Posts", ctx)
        ret0, _ := ret[0].([]*entities.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Posts indicates an expected call of Posts.
func (mr *MockPostRepositoryMockRecorder) Posts(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Posts", reflect.TypeOf((*MockPostRepository)(nil).Posts), ctx)
}</span>

// UpdatePost mocks base method.
func (m *MockPostRepository) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdatePost", ctx, post)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdatePost indicates an expected call of UpdatePost.
func (mr *MockPostRepositoryMockRecorder) UpdatePost(ctx, post any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePost", reflect.TypeOf((*MockPostRepository)(nil).UpdatePost), ctx, post)
}</span>

// MockCommentRepository is a mock of CommentRepository interface.
type MockCommentRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCommentRepositoryMockRecorder
        isgomock struct{}
}

// MockCommentRepositoryMockRecorder is the mock recorder for MockCommentRepository.
type MockCommentRepositoryMockRecorder struct {
        mock *MockCommentRepository
}

// NewMockCommentRepository creates a new mock instance.
func NewMockCommentRepository(ctrl *gomock.Controller) *MockCommentRepository <span class="cov8" title="1">{
        mock := &amp;MockCommentRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCommentRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentRepository) EXPECT() *MockCommentRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateComment mocks base method.
func (m *MockCommentRepository) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateComment indicates an expected call of CreateComment.
func (mr *MockCommentRepositoryMockRecorder) CreateComment(ctx, comment any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateComment", reflect.TypeOf((*MockCommentRepository)(nil).CreateComment), ctx, comment)
}</span>

// DeleteComment mocks base method.
func (m *MockCommentRepository) DeleteComment(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteComment", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteComment indicates an expected call of DeleteComment.
func (mr *MockCommentRepositoryMockRecorder) DeleteComment(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteComment", reflect.TypeOf((*MockCommentRepository)(nil).DeleteComment), ctx, id)
}</span>

// GetByPostID mocks base method.
func (m *MockCommentRepository) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByPostID", ctx, postID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByPostID indicates an expected call of GetByPostID.
func (mr *MockCommentRepositoryMockRecorder) GetByPostID(ctx, postID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPostID", reflect.TypeOf((*MockCommentRepository)(nil).GetByPostID), ctx, postID)
}</span>

// GetByUserID mocks base method.
func (m *MockCommentRepository) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUserID", ctx, userID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUserID indicates an expected call of GetByUserID.
func (mr *MockCommentRepositoryMockRecorder) GetByUserID(ctx, userID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUserID", reflect.TypeOf((*MockCommentRepository)(nil).GetByUserID), ctx, userID)
}</span>

// GetCommentByID mocks base method.
func (m *MockCommentRepository) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCommentByID", ctx, id)
        ret0, _ := ret[0].(*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCommentByID indicates an expected call of GetCommentByID.
func (mr *MockCommentRepositoryMockRecorder) GetCommentByID(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommentByID", reflect.TypeOf((*MockCommentRepository)(nil).GetCommentByID), ctx, id)
}</span>

// UpdateComment mocks base method.
func (m *MockCommentRepository) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateComment indicates an expected call of UpdateComment.
func (mr *MockCommentRepositoryMockRecorder) UpdateComment(ctx, comment any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateComment", reflect.TypeOf((*MockCommentRepository)(nil).UpdateComment), ctx, comment)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "back/forum_service/internal/usecase"
        "back/pkg/logger"
        "context"
        "time"
)

type CleanupService struct {
        chatUC *usecase.ChatUsecase
        logger logger.Logger
        stop   chan struct{}
}

func NewCleanupService(chatUC *usecase.ChatUsecase, logger logger.Logger) *CleanupService <span class="cov0" title="0">{
        return &amp;CleanupService{
                chatUC: chatUC,
                logger: logger,
                stop:   make(chan struct{}),
        }
}</span>

func (s *CleanupService) Start(interval, lifetime time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := s.cleanupOldMessages(lifetime); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("cleanup failed",
                                                logger.NewField("error", err))
                                }</span>
                        case &lt;-s.stop:<span class="cov0" title="0">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *CleanupService) Stop() <span class="cov0" title="0">{
        s.stop &lt;- struct{}{}
}</span>

func (s *CleanupService) cleanupOldMessages(lifetime time.Duration) error <span class="cov0" title="0">{
        cutoff := time.Now().Add(-lifetime)
        return s.chatUC.DeleteOldMessages(context.Background(), cutoff)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package usecase

import (
        "back/forum_service/internal/entities"
        "back/forum_service/internal/repository"
        "back/pkg/errors"
        "back/pkg/logger"
        pb "back/proto"
        "context"
        "fmt"
        "time"
)

type ChatUsecaseInterface interface {
        DeleteOldMessages(ctx context.Context, cutoff time.Time) error
        GetMessages(ctx context.Context) ([]*entities.ChatMessage, error)
        SendMessage(ctx context.Context, msg *entities.ChatMessage) error
}

type ChatUsecase struct {
        repo            repository.ChatRepository
        logger          logger.Logger
        maxMessageLen   int
        messageLifetime time.Duration
}

func NewChatUsecase(repo repository.ChatRepository, logger logger.Logger, config *pb.ChatConfig) *ChatUsecase <span class="cov0" title="0">{
        return &amp;ChatUsecase{
                repo:            repo,
                logger:          logger,
                maxMessageLen:   int(config.MaxMessageLength),
                messageLifetime: time.Duration(config.MessageLifetimeMinutes) * time.Minute,
        }
}</span>

func (u *ChatUsecase) SendMessage(ctx context.Context, msg *entities.ChatMessage) error <span class="cov0" title="0">{
        if len(msg.Content) &gt; u.maxMessageLen </span><span class="cov0" title="0">{
                return fmt.Errorf("сообщение слишком длинное (максимум %d символов)", u.maxMessageLen)
        }</span>
        <span class="cov0" title="0">if msg.Content == "" </span><span class="cov0" title="0">{
                return errors.ErrEmptyMessage
        }</span>

        <span class="cov0" title="0">u.logger.Info("отправка сообщения в чат",
                logger.NewField("user_id", msg.UserID),
                logger.NewField("content_len", len(msg.Content)),
        )
        return u.repo.SaveMessage(ctx, msg.UserID, msg.Content)</span>
}

func (u *ChatUsecase) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov0" title="0">{
        return u.repo.GetMessages(ctx)
}</span>

func (u *ChatUsecase) DeleteOldMessages(ctx context.Context, before time.Time) error <span class="cov0" title="0">{
        u.logger.Info("deleting old messages",
                logger.NewField("before", before))
        return u.repo.DeleteOldMessages(ctx, before)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package usecase

import (
        "back/forum_service/internal/entities"
        "back/forum_service/internal/repository"
        "back/pkg/logger"
        "context"
        "time"
)

type CleanupService struct {
        chatUC  ChatUsecaseInterface
        logger  logger.Logger
        ticker  *time.Ticker
        done    chan bool
        timeout time.Duration
}

func NewCleanupService(chatUC ChatUsecaseInterface, logger logger.Logger) *CleanupService <span class="cov8" title="1">{
        return &amp;CleanupService{
                chatUC:  chatUC,
                logger:  logger,
                done:    make(chan bool),
                timeout: 30 * time.Second,
        }
}</span>

func (s *CleanupService) Start(interval time.Duration, messageLifetime time.Duration) <span class="cov8" title="1">{
        s.ticker = time.NewTicker(interval)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov8" title="1">
                                if err := s.Cleanup(messageLifetime); err != nil </span><span class="cov8" title="1">{
                                        s.logger.Error("failed to cleanup messages",
                                                logger.NewField("error", err))
                                }</span>
                        case &lt;-s.done:<span class="cov8" title="1">
                                s.ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *CleanupService) Stop() <span class="cov8" title="1">{
        s.done &lt;- true
}</span>

func (s *CleanupService) Cleanup(messageLifetime time.Duration) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), s.timeout)
        defer cancel()

        cutoff := time.Now().Add(-messageLifetime)

        if err := s.chatUC.DeleteOldMessages(ctx, cutoff); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("ошибка очистки старых сообщений",
                        logger.NewField("error", err),
                        logger.NewField("cutoff", cutoff),
                )
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info("успешная очистка старых сообщений",
                logger.NewField("cutoff", cutoff),
        )
        return nil</span>
}

type PostUsecase struct {
        repo   repository.PostRepository
        logger logger.Logger
}

func NewPostUsecase(repo repository.PostRepository, logger logger.Logger) *PostUsecase <span class="cov8" title="1">{
        return &amp;PostUsecase{
                repo:   repo,
                logger: logger,
        }
}</span>

func (u *PostUsecase) CreatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        u.logger.Info("создание нового поста",
                logger.NewField("title", post.Title),
                logger.NewField("author_id", post.AuthorID))

        return u.repo.CreatePost(ctx, post)
}</span>

func (u *PostUsecase) GetPostByID(ctx context.Context, id int64) (*entities.Post, error) <span class="cov8" title="1">{
        u.logger.Info("получение поста по ID",
                logger.NewField("post_id", id))

        return u.repo.GetPostByID(ctx, id)
}</span>

func (u *PostUsecase) UpdatePost(ctx context.Context, post *entities.Post) error <span class="cov8" title="1">{
        u.logger.Info("обновление поста",
                logger.NewField("post_id", post.ID))
        return u.repo.UpdatePost(ctx, post)
}</span>

func (u *PostUsecase) DeletePost(ctx context.Context, id int64) error <span class="cov8" title="1">{
        u.logger.Info("удаление поста по ID",
                logger.NewField("post_id", id))
        return u.repo.DeletePost(ctx, id)
}</span>

func (u *PostUsecase) Posts(ctx context.Context) ([]*entities.Post, error) <span class="cov8" title="1">{
        return u.repo.Posts(ctx)
}</span>

type CommentUsecaseInterface interface {
        CreateComment(ctx context.Context, comment *entities.Comment) error
        GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error)
        UpdateComment(ctx context.Context, comment *entities.Comment) error
        DeleteComment(ctx context.Context, id int64) error
        GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error)
        GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error)
}

type CommentUsecase struct {
        repo   repository.CommentRepository
        logger logger.Logger
}

func NewCommentUsecase(repo repository.CommentRepository, logger logger.Logger) *CommentUsecase <span class="cov8" title="1">{
        return &amp;CommentUsecase{
                repo:   repo,
                logger: logger,
        }
}</span>

func (u *CommentUsecase) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        u.logger.Info("создание нового комментария",
                logger.NewField("comment_id", comment.ID))
        return u.repo.CreateComment(ctx, comment)
}</span>

func (u *CommentUsecase) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментария по ID",
                logger.NewField("comment_id", id))
        return u.repo.GetCommentByID(ctx, id)
}</span>

func (u *CommentUsecase) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментариев по ID поста",
                logger.NewField("post_id", postID))
        return u.repo.GetByPostID(ctx, postID)
}</span>

func (u *CommentUsecase) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov8" title="1">{
        u.logger.Info("получение комментариев по ID пользователя",
                logger.NewField("user_id", userID))
        return u.repo.GetByUserID(ctx, userID)
}</span>

func (u *CommentUsecase) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov8" title="1">{
        u.logger.Info("обновление комментария",
                logger.NewField("comment_id", comment.ID))
        return u.repo.UpdateComment(ctx, comment)
}</span>

func (u *CommentUsecase) DeleteComment(ctx context.Context, commentId int64) error <span class="cov8" title="1">{
        u.logger.Info("удаление комментария",
                logger.NewField("comment_id", commentId))
        return u.repo.DeleteComment(ctx, commentId)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/usecase/chat.go
//
// Generated by this command:
//
//        mockgen -source=forum_service/internal/usecase/chat.go -destination=forum_service/internal/usecase/mocks/ucChat_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "back/forum_service/internal/entities"
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockChatUsecaseInterface is a mock of ChatUsecaseInterface interface.
type MockChatUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockChatUsecaseInterfaceMockRecorder
        isgomock struct{}
}

// MockChatUsecaseInterfaceMockRecorder is the mock recorder for MockChatUsecaseInterface.
type MockChatUsecaseInterfaceMockRecorder struct {
        mock *MockChatUsecaseInterface
}

// NewMockChatUsecaseInterface creates a new mock instance.
func NewMockChatUsecaseInterface(ctrl *gomock.Controller) *MockChatUsecaseInterface <span class="cov8" title="1">{
        mock := &amp;MockChatUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockChatUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatUsecaseInterface) EXPECT() *MockChatUsecaseInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteOldMessages mocks base method.
func (m *MockChatUsecaseInterface) DeleteOldMessages(ctx context.Context, cutoff time.Time) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteOldMessages", ctx, cutoff)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteOldMessages indicates an expected call of DeleteOldMessages.
func (mr *MockChatUsecaseInterfaceMockRecorder) DeleteOldMessages(ctx, cutoff any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOldMessages", reflect.TypeOf((*MockChatUsecaseInterface)(nil).DeleteOldMessages), ctx, cutoff)
}</span>

// GetMessages mocks base method.
func (m *MockChatUsecaseInterface) GetMessages(ctx context.Context) ([]*entities.ChatMessage, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMessages", ctx)
        ret0, _ := ret[0].([]*entities.ChatMessage)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMessages indicates an expected call of GetMessages.
func (mr *MockChatUsecaseInterfaceMockRecorder) GetMessages(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessages", reflect.TypeOf((*MockChatUsecaseInterface)(nil).GetMessages), ctx)
}</span>

// SendMessage mocks base method.
func (m *MockChatUsecaseInterface) SendMessage(ctx context.Context, msg *entities.ChatMessage) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendMessage", ctx, msg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendMessage indicates an expected call of SendMessage.
func (mr *MockChatUsecaseInterfaceMockRecorder) SendMessage(ctx, msg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockChatUsecaseInterface)(nil).SendMessage), ctx, msg)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: forum_service/internal/usecase/forum.go
//
// Generated by this command:
//
//        mockgen -source=forum_service/internal/usecase/forum.go -destination=forum_service/internal/usecase/mocks/uc_mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        entities "back/forum_service/internal/entities"
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockCommentUsecaseInterface is a mock of CommentUsecaseInterface interface.
type MockCommentUsecaseInterface struct {
        ctrl     *gomock.Controller
        recorder *MockCommentUsecaseInterfaceMockRecorder
        isgomock struct{}
}

// MockCommentUsecaseInterfaceMockRecorder is the mock recorder for MockCommentUsecaseInterface.
type MockCommentUsecaseInterfaceMockRecorder struct {
        mock *MockCommentUsecaseInterface
}

// NewMockCommentUsecaseInterface creates a new mock instance.
func NewMockCommentUsecaseInterface(ctrl *gomock.Controller) *MockCommentUsecaseInterface <span class="cov0" title="0">{
        mock := &amp;MockCommentUsecaseInterface{ctrl: ctrl}
        mock.recorder = &amp;MockCommentUsecaseInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommentUsecaseInterface) EXPECT() *MockCommentUsecaseInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateComment mocks base method.
func (m *MockCommentUsecaseInterface) CreateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateComment indicates an expected call of CreateComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) CreateComment(ctx, comment any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).CreateComment), ctx, comment)
}</span>

// DeleteComment mocks base method.
func (m *MockCommentUsecaseInterface) DeleteComment(ctx context.Context, id int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteComment", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteComment indicates an expected call of DeleteComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) DeleteComment(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).DeleteComment), ctx, id)
}</span>

// GetByPostID mocks base method.
func (m *MockCommentUsecaseInterface) GetByPostID(ctx context.Context, postID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByPostID", ctx, postID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByPostID indicates an expected call of GetByPostID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetByPostID(ctx, postID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPostID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetByPostID), ctx, postID)
}</span>

// GetByUserID mocks base method.
func (m *MockCommentUsecaseInterface) GetByUserID(ctx context.Context, userID int64) ([]*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUserID", ctx, userID)
        ret0, _ := ret[0].([]*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUserID indicates an expected call of GetByUserID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetByUserID(ctx, userID any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUserID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetByUserID), ctx, userID)
}</span>

// GetCommentByID mocks base method.
func (m *MockCommentUsecaseInterface) GetCommentByID(ctx context.Context, id int64) (*entities.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCommentByID", ctx, id)
        ret0, _ := ret[0].(*entities.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCommentByID indicates an expected call of GetCommentByID.
func (mr *MockCommentUsecaseInterfaceMockRecorder) GetCommentByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommentByID", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).GetCommentByID), ctx, id)
}</span>

// UpdateComment mocks base method.
func (m *MockCommentUsecaseInterface) UpdateComment(ctx context.Context, comment *entities.Comment) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateComment", ctx, comment)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateComment indicates an expected call of UpdateComment.
func (mr *MockCommentUsecaseInterfaceMockRecorder) UpdateComment(ctx, comment any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateComment", reflect.TypeOf((*MockCommentUsecaseInterface)(nil).UpdateComment), ctx, comment)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package database

import (
        "back/pkg/logger"
        "fmt"

        "github.com/golang-migrate/migrate"
)

func RunMigrations(dbURL string, log logger.Logger) error <span class="cov0" title="0">{
        m, err := migrate.New(
                "file://migrations",
                dbURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("migrations completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package logger

// Logger определяет интерфейс для логирования
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)
}

// Field представляет поле с дополнительной информацией для лога
type Field struct {
        Key   string
        Value interface{}
}

// NewField создает новое поле для лога
func NewField(key string, value interface{}) Field <span class="cov8" title="1">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package logger

import (
    "fmt"
    "log"
    "os"
)

type stdLogger struct {
    debug *log.Logger
    info  *log.Logger
    warn  *log.Logger
    error *log.Logger
    fatal *log.Logger
}

// NewStdLogger создает новый логгер на основе стандартного log пакета
func NewStdLogger() Logger <span class="cov8" title="1">{
    return &amp;stdLogger{
        debug: log.New(os.Stdout, "DEBUG: ", log.Ldate|log.Ltime|log.Lshortfile),
        info:  log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile),
        warn:  log.New(os.Stdout, "WARN: ", log.Ldate|log.Ltime|log.Lshortfile),
        error: log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile),
        fatal: log.New(os.Stderr, "FATAL: ", log.Ldate|log.Ltime|log.Lshortfile),
    }
}</span>

func (l *stdLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
    l.debug.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
    l.info.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
    l.warn.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
    l.error.Output(2, formatMsg(msg, fields...))
}</span>

func (l *stdLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
    l.fatal.Output(2, formatMsg(msg, fields...))
    os.Exit(1)
}</span>

// formatMsg форматирует сообщение с дополнительными полями
func formatMsg(msg string, fields ...Field) string <span class="cov8" title="1">{
    if len(fields) == 0 </span><span class="cov8" title="1">{
        return msg
    }</span>
    
    <span class="cov8" title="1">result := msg + " {"
    for i, f := range fields </span><span class="cov8" title="1">{
        if i &gt; 0 </span><span class="cov8" title="1">{
            result += ", "
        }</span>
        <span class="cov8" title="1">result += fmt.Sprintf("%s: %v", f.Key, f.Value)</span>
    }
    <span class="cov8" title="1">result += "}"
    return result</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v6.30.2
// source: proto/forum.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ================== Error Handling ==================
type ErrorCode int32

const (
        ErrorCode_ERROR_UNSPECIFIED         ErrorCode = 0
        ErrorCode_ERROR_INVALID_CREDENTIALS ErrorCode = 1
        ErrorCode_ERROR_USER_NOT_FOUND      ErrorCode = 2
        ErrorCode_ERROR_USER_ALREADY_EXISTS ErrorCode = 3
        ErrorCode_ERROR_TOKEN_EXPIRED       ErrorCode = 4
        ErrorCode_ERROR_PERMISSION_DENIED   ErrorCode = 5
)

// Enum value maps for ErrorCode.
var (
        ErrorCode_name = map[int32]string{
                0: "ERROR_UNSPECIFIED",
                1: "ERROR_INVALID_CREDENTIALS",
                2: "ERROR_USER_NOT_FOUND",
                3: "ERROR_USER_ALREADY_EXISTS",
                4: "ERROR_TOKEN_EXPIRED",
                5: "ERROR_PERMISSION_DENIED",
        }
        ErrorCode_value = map[string]int32{
                "ERROR_UNSPECIFIED":         0,
                "ERROR_INVALID_CREDENTIALS": 1,
                "ERROR_USER_NOT_FOUND":      2,
                "ERROR_USER_ALREADY_EXISTS": 3,
                "ERROR_TOKEN_EXPIRED":       4,
                "ERROR_PERMISSION_DENIED":   5,
        }
)

func (x ErrorCode) Enum() *ErrorCode <span class="cov0" title="0">{
        p := new(ErrorCode)
        *p = x
        return p
}</span>

func (x ErrorCode) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_forum_proto_enumTypes[0].Descriptor()
}</span>

func (ErrorCode) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_forum_proto_enumTypes[0]
}</span>

func (x ErrorCode) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{0}
}</span>

// Определяем собственное пустое сообщение
type EmptyMessage struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *EmptyMessage) Reset() <span class="cov0" title="0">{
        *x = EmptyMessage{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EmptyMessage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EmptyMessage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EmptyMessage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EmptyMessage.ProtoReflect.Descriptor instead.
func (*EmptyMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{0}
}</span>

type RegisterRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken  string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresAt    int64  `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RegisterResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken  string               `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken string               `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresAt    int64                `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"` // Unix timestamp
        User         *UserProfileResponse `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{4}
}</span>

func (x *LoginResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetUser() *UserProfileResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RefreshTokenRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RefreshToken string `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (x *RefreshTokenRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{5}
}</span>

func (x *RefreshTokenRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshTokenResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken  string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (x *RefreshTokenResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{6}
}</span>

func (x *RefreshTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ValidateRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (x *ValidateRequest) Reset() <span class="cov0" title="0">{
        *x = ValidateRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValidateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateRequest.ProtoReflect.Descriptor instead.
func (*ValidateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ValidateRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ValidateResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        IsValid  bool   `protobuf:"varint,1,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
        UserId   int64  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
        IsAdmin  bool   `protobuf:"varint,4,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
}

func (x *ValidateResponse) Reset() <span class="cov0" title="0">{
        *x = ValidateResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValidateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateResponse.ProtoReflect.Descriptor instead.
func (*ValidateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{8}
}</span>

func (x *ValidateResponse) GetIsValid() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsValid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ValidateResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ValidateResponse) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidateResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{9}
}</span>

func (x *LogoutRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{10}
}</span>

func (x *LogoutResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ================== Post Service ==================
type Post struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id             int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Title          string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        Content        string `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64  `protobuf:"varint,4,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        AuthorUsername string `protobuf:"bytes,5,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        CreatedAt      int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        CommentCount   int32  `protobuf:"varint,7,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
}

func (x *Post) Reset() <span class="cov0" title="0">{
        *x = Post{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Post) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Post) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Post) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Post.ProtoReflect.Descriptor instead.
func (*Post) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{11}
}</span>

func (x *Post) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Post) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Post) GetCommentCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PostResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Post *Post `protobuf:"bytes,1,opt,name=post,proto3" json:"post,omitempty"`
}

func (x *PostResponse) Reset() <span class="cov0" title="0">{
        *x = PostResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PostResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PostResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PostResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PostResponse.ProtoReflect.Descriptor instead.
func (*PostResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{12}
}</span>

func (x *PostResponse) GetPost() *Post <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Post
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreatePostRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Title    string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        Content  string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId int64  `protobuf:"varint,3,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
}

func (x *CreatePostRequest) Reset() <span class="cov0" title="0">{
        *x = CreatePostRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreatePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreatePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreatePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreatePostRequest.ProtoReflect.Descriptor instead.
func (*CreatePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{13}
}</span>

func (x *CreatePostRequest) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreatePostRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreatePostRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetPostRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PostId int64 `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
}

func (x *GetPostRequest) Reset() <span class="cov0" title="0">{
        *x = GetPostRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetPostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPostRequest.ProtoReflect.Descriptor instead.
func (*GetPostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetPostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdatePostRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PostId  int64   `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        Title   *string `protobuf:"bytes,2,opt,name=title,proto3,oneof" json:"title,omitempty"`
        Content *string `protobuf:"bytes,3,opt,name=content,proto3,oneof" json:"content,omitempty"`
}

func (x *UpdatePostRequest) Reset() <span class="cov0" title="0">{
        *x = UpdatePostRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdatePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdatePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdatePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdatePostRequest.ProtoReflect.Descriptor instead.
func (*UpdatePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{15}
}</span>

func (x *UpdatePostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdatePostRequest) GetTitle() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Title != nil </span><span class="cov0" title="0">{
                return *x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdatePostRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Content != nil </span><span class="cov0" title="0">{
                return *x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeletePostRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PostId int64 `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        UserId int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` // Для проверки прав
}

func (x *DeletePostRequest) Reset() <span class="cov0" title="0">{
        *x = DeletePostRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeletePostRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeletePostRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeletePostRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeletePostRequest.ProtoReflect.Descriptor instead.
func (*DeletePostRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{16}
}</span>

func (x *DeletePostRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeletePostRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListPostsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Limit    int32  `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        AuthorId *int64 `protobuf:"varint,2,opt,name=author_id,json=authorId,proto3,oneof" json:"author_id,omitempty"`
}

func (x *ListPostsRequest) Reset() <span class="cov0" title="0">{
        *x = ListPostsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[17]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListPostsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListPostsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListPostsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[17]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListPostsRequest.ProtoReflect.Descriptor instead.
func (*ListPostsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{17}
}</span>

func (x *ListPostsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListPostsRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.AuthorId != nil </span><span class="cov0" title="0">{
                return *x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListPostsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Posts      []*Post `protobuf:"bytes,1,rep,name=posts,proto3" json:"posts,omitempty"`
        TotalCount int32   `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (x *ListPostsResponse) Reset() <span class="cov0" title="0">{
        *x = ListPostsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[18]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListPostsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListPostsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListPostsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[18]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListPostsResponse.ProtoReflect.Descriptor instead.
func (*ListPostsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{18}
}</span>

func (x *ListPostsResponse) GetPosts() []*Post <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Posts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListPostsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ================== Comment Service ==================
type Comment struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id             int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Content        string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId       int64  `protobuf:"varint,3,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        AuthorUsername string `protobuf:"bytes,4,opt,name=author_username,json=authorUsername,proto3" json:"author_username,omitempty"`
        PostId         int64  `protobuf:"varint,5,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
        CreatedAt      int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *Comment) Reset() <span class="cov0" title="0">{
        *x = Comment{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[19]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Comment) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Comment) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Comment) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[19]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Comment.ProtoReflect.Descriptor instead.
func (*Comment) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{19}
}</span>

func (x *Comment) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Comment) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetAuthorUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorUsername
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Comment) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comment) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CommentResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Comment *Comment `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (x *CommentResponse) Reset() <span class="cov0" title="0">{
        *x = CommentResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[20]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[20]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommentResponse.ProtoReflect.Descriptor instead.
func (*CommentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{20}
}</span>

func (x *CommentResponse) GetComment() *Comment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comment
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateCommentRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Content  string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
        AuthorId int64  `protobuf:"varint,2,opt,name=author_id,json=authorId,proto3" json:"author_id,omitempty"`
        PostId   int64  `protobuf:"varint,3,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
}

func (x *CreateCommentRequest) Reset() <span class="cov0" title="0">{
        *x = CreateCommentRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[21]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[21]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{21}
}</span>

func (x *CreateCommentRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateCommentRequest) GetAuthorId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateCommentRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetCommentRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CommentId int64 `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
}

func (x *GetCommentRequest) Reset() <span class="cov0" title="0">{
        *x = GetCommentRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[22]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[22]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCommentRequest.ProtoReflect.Descriptor instead.
func (*GetCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{22}
}</span>

func (x *GetCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListCommentsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PostId int64 `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty"`
}

func (x *ListCommentsRequest) Reset() <span class="cov0" title="0">{
        *x = ListCommentsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[23]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListCommentsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCommentsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCommentsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[23]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListCommentsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{23}
}</span>

func (x *ListCommentsRequest) GetPostId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListCommentsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Comments   []*Comment `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
        TotalCount int32      `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (x *ListCommentsResponse) Reset() <span class="cov0" title="0">{
        *x = ListCommentsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[24]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListCommentsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListCommentsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListCommentsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[24]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListCommentsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{24}
}</span>

func (x *ListCommentsResponse) GetComments() []*Comment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListCommentsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateCommentRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CommentId int64   `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
        Content   *string `protobuf:"bytes,2,opt,name=content,proto3,oneof" json:"content,omitempty"`
}

func (x *UpdateCommentRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateCommentRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[25]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[25]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateCommentRequest.ProtoReflect.Descriptor instead.
func (*UpdateCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{25}
}</span>

func (x *UpdateCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateCommentRequest) GetContent() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Content != nil </span><span class="cov0" title="0">{
                return *x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteCommentRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CommentId int64 `protobuf:"varint,1,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
        UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` // Для проверки прав
}

func (x *DeleteCommentRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteCommentRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[26]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteCommentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteCommentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteCommentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[26]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteCommentRequest.ProtoReflect.Descriptor instead.
func (*DeleteCommentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{26}
}</span>

func (x *DeleteCommentRequest) GetCommentId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeleteCommentRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ================== Chat Service ==================
type ChatMessage struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId    int64  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Content   string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
        CreatedAt int64  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
}

func (x *ChatMessage) Reset() <span class="cov0" title="0">{
        *x = ChatMessage{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[27]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ChatMessage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChatMessage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChatMessage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[27]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChatMessage.ProtoReflect.Descriptor instead.
func (*ChatMessage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{27}
}</span>

func (x *ChatMessage) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatMessage) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ChatMessage) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetMessagesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Limit int32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        After int64 `protobuf:"varint,2,opt,name=after,proto3" json:"after,omitempty"` // Unix timestamp
}

func (x *GetMessagesRequest) Reset() <span class="cov0" title="0">{
        *x = GetMessagesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[28]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMessagesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMessagesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMessagesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[28]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMessagesRequest.ProtoReflect.Descriptor instead.
func (*GetMessagesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{28}
}</span>

func (x *GetMessagesRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetMessagesRequest) GetAfter() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.After
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetMessagesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Messages   []*ChatMessage `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
        TotalCount int32          `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (x *GetMessagesResponse) Reset() <span class="cov0" title="0">{
        *x = GetMessagesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[29]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetMessagesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMessagesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMessagesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[29]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMessagesResponse.ProtoReflect.Descriptor instead.
func (*GetMessagesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{29}
}</span>

func (x *GetMessagesResponse) GetMessages() []*ChatMessage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Messages
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMessagesResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ChatConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        MessageLifetimeMinutes int32 `protobuf:"varint,1,opt,name=message_lifetime_minutes,json=messageLifetimeMinutes,proto3" json:"message_lifetime_minutes,omitempty"` // Время жизни сообщений
        MaxMessageLength       int32 `protobuf:"varint,2,opt,name=max_message_length,json=maxMessageLength,proto3" json:"max_message_length,omitempty"`                   // Максимальная длина сообщения
        OnlyAuthenticated      bool  `protobuf:"varint,3,opt,name=only_authenticated,json=onlyAuthenticated,proto3" json:"only_authenticated,omitempty"`                  // Только для авторизованных
}

func (x *ChatConfig) Reset() <span class="cov0" title="0">{
        *x = ChatConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[30]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ChatConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChatConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChatConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[30]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChatConfig.ProtoReflect.Descriptor instead.
func (*ChatConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{30}
}</span>

func (x *ChatConfig) GetMessageLifetimeMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageLifetimeMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatConfig) GetMaxMessageLength() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxMessageLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ChatConfig) GetOnlyAuthenticated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OnlyAuthenticated
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Общая модель пользователя для всех сервисов
type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id        int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        CreatedAt int64  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[31]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[31]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{31}
}</span>

func (x *User) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[32]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[32]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{32}
}</span>

func (x *GetUserRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserProfileResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId       int64  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
        Username     string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        CreatedAt    int64  `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"` // Unix timestamp
        PostCount    int32  `protobuf:"varint,4,opt,name=post_count,json=postCount,proto3" json:"post_count,omitempty"`
        CommentCount int32  `protobuf:"varint,5,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
        IsAdmin      bool   `protobuf:"varint,6,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
}

func (x *UserProfileResponse) Reset() <span class="cov0" title="0">{
        *x = UserProfileResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[33]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserProfileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserProfileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserProfileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[33]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserProfileResponse.ProtoReflect.Descriptor instead.
func (*UserProfileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{33}
}</span>

func (x *UserProfileResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfileResponse) GetCreatedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetPostCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PostCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetCommentCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CommentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfileResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

type UpdateUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[34]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[34]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{34}
}</span>

func (x *UpdateUserRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Error struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Code    ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=proto.ErrorCode" json:"code,omitempty"`
        Message string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *Error) Reset() <span class="cov0" title="0">{
        *x = Error{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[35]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Error) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Error) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Error) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[35]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{35}
}</span>

func (x *Error) GetCode() ErrorCode <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ErrorCode_ERROR_UNSPECIFIED</span>
}

func (x *Error) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CheckAdminRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *CheckAdminRequest) Reset() <span class="cov0" title="0">{
        *x = CheckAdminRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[36]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CheckAdminRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckAdminRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckAdminRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[36]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckAdminRequest.ProtoReflect.Descriptor instead.
func (*CheckAdminRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{36}
}</span>

func (x *CheckAdminRequest) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CheckAdminResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        IsAdmin bool `protobuf:"varint,1,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
}

func (x *CheckAdminResponse) Reset() <span class="cov0" title="0">{
        *x = CheckAdminResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_forum_proto_msgTypes[37]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CheckAdminResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckAdminResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckAdminResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_forum_proto_msgTypes[37]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckAdminResponse.ProtoReflect.Descriptor instead.
func (*CheckAdminResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_forum_proto_rawDescGZIP(), []int{37}
}</span>

func (x *CheckAdminResponse) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_proto_forum_proto protoreflect.FileDescriptor

var file_proto_forum_proto_rawDesc = []byte{
        0x0a, 0x11, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x66, 0x6f, 0x72, 0x75, 0x6d, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x12, 0x05, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x0e, 0x0a, 0x0c, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x49, 0x0a, 0x0f, 0x52, 0x65,
        0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x79, 0x0a, 0x10, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
        0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d,
        0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65,
        0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x74, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74,
        0x22, 0x46, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08,
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0xa6, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67,
        0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63,
        0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x23, 0x0a,
        0x0d, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b,
        0x65, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x74,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41,
        0x74, 0x12, 0x2e, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x66,
        0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x04, 0x75, 0x73, 0x65,
        0x72, 0x22, 0x3a, 0x0a, 0x13, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65,
        0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72,
        0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x5e, 0x0a,
        0x14, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f,
        0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72,
        0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x34, 0x0a,
        0x0f, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x22, 0x7d, 0x0a, 0x10, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x56, 0x61, 0x6c,
        0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x75,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x61, 0x64,
        0x6d, 0x69, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x41, 0x64, 0x6d,
        0x69, 0x6e, 0x22, 0x32, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73,
        0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x2a, 0x0a, 0x0e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65,
        0x73, 0x73, 0x22, 0xd0, 0x01, 0x0a, 0x04, 0x50, 0x6f, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x74,
        0x69, 0x74, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c,
        0x65, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x61,
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08,
        0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x61, 0x75, 0x74, 0x68,
        0x6f, 0x72, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
        0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
        0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e,
        0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
        0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x2f, 0x0a, 0x0c, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x04, 0x70, 0x6f, 0x73, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x6f, 0x73, 0x74,
        0x52, 0x04, 0x70, 0x6f, 0x73, 0x74, 0x22, 0x60, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x74,
        0x69, 0x74, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c,
        0x65, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x61,
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08,
        0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x64, 0x22, 0x29, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x50,
        0x6f, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f,
        0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x70, 0x6f, 0x73,
        0x74, 0x49, 0x64, 0x22, 0x7c, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x73,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x73, 0x74,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x70, 0x6f, 0x73, 0x74, 0x49,
        0x64, 0x12, 0x19, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x48, 0x00, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x88, 0x01, 0x01, 0x12, 0x1d, 0x0a, 0x07,
        0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52,
        0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x5f,
        0x74, 0x69, 0x74, 0x6c, 0x65, 0x42, 0x0a, 0x0a, 0x08, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x22, 0x45, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x74, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x73, 0x74, 0x5f, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x70, 0x6f, 0x73, 0x74, 0x49, 0x64, 0x12,
        0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x58, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74,
        0x50, 0x6f, 0x73, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05,
        0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d,
        0x69, 0x74, 0x12, 0x20, 0x0a, 0x09, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52, 0x08, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49,
        0x64, 0x88, 0x01, 0x01, 0x42, 0x0c, 0x0a, 0x0a, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f,
        0x69, 0x64, 0x22, 0x57, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x6f, 0x73, 0x74, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x05, 0x70, 0x6f, 0x73, 0x74, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50,
        0x6f, 0x73, 0x74, 0x52, 0x05, 0x70, 0x6f, 0x73, 0x74, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f,
        0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xb1, 0x01, 0x0a, 0x07,
        0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65,
        0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x12, 0x1b, 0x0a, 0x09, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x27,
        0x0a, 0x0f, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x55,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x73, 0x74, 0x5f,
        0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x70, 0x6f, 0x73, 0x74, 0x49, 0x64,
        0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22,
        0x3b, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x28, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
        0x65, 0x6e, 0x74, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x22, 0x66, 0x0a, 0x14,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x1b,
        0x0a, 0x09, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x03, 0x52, 0x08, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x70,
        0x6f, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x70, 0x6f,
        0x73, 0x74, 0x49, 0x64, 0x22, 0x32, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6f, 0x6d,
        0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63,
        0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x22, 0x2e, 0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74,
        0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x17, 0x0a, 0x07, 0x70, 0x6f, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x06, 0x70, 0x6f, 0x73, 0x74, 0x49, 0x64, 0x22, 0x63, 0x0a, 0x14, 0x4c, 0x69, 0x73, 0x74,
        0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x2a, 0x0a, 0x08, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x52, 0x08, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x1f, 0x0a, 0x0b,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x60, 0x0a,
        0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
        0x88, 0x01, 0x01, 0x42, 0x0a, 0x0a, 0x08, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22,
        0x4e, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x6f, 0x6d,
        0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69,
        0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22,
        0x5f, 0x0a, 0x0b, 0x43, 0x68, 0x61, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x17,
        0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65,
        0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
        0x22, 0x40, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x14, 0x0a, 0x05,
        0x61, 0x66, 0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x61, 0x66, 0x74,
        0x65, 0x72, 0x22, 0x66, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x08, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x68, 0x61, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52,
        0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74,
        0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xa3, 0x01, 0x0a, 0x0a, 0x43,
        0x68, 0x61, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x38, 0x0a, 0x18, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6d, 0x69,
        0x6e, 0x75, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x16, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x4c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x4d, 0x69, 0x6e, 0x75,
        0x74, 0x65, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x10, 0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4c, 0x65, 0x6e, 0x67, 0x74,
        0x68, 0x12, 0x2d, 0x0a, 0x12, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,
        0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x6f,
        0x6e, 0x6c, 0x79, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64,
        0x22, 0x51, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x41, 0x74, 0x22, 0x29, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0xc7,
        0x01, 0x0a, 0x13, 0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1a,
        0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09,
        0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x6f, 0x73,
        0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x70,
        0x6f, 0x73, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6d, 0x6d,
        0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x19, 0x0a,
        0x08, 0x69, 0x73, 0x5f, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x07, 0x69, 0x73, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x22, 0x2c, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a,
        0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06,
        0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x47, 0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12,
        0x24, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x52,
        0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22,
        0x2c, 0x0a, 0x11, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x2f, 0x0a,
        0x12, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x2a, 0xb0,
        0x01, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x15, 0x0a, 0x11,
        0x45, 0x52, 0x52, 0x4f, 0x52, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
        0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a, 0x19, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x5f, 0x49, 0x4e, 0x56,
        0x41, 0x4c, 0x49, 0x44, 0x5f, 0x43, 0x52, 0x45, 0x44, 0x45, 0x4e, 0x54, 0x49, 0x41, 0x4c, 0x53,
        0x10, 0x01, 0x12, 0x18, 0x0a, 0x14, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x5f, 0x55, 0x53, 0x45, 0x52,
        0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x46, 0x4f, 0x55, 0x4e, 0x44, 0x10, 0x02, 0x12, 0x1d, 0x0a, 0x19,
        0x45, 0x52, 0x52, 0x4f, 0x52, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x41, 0x4c, 0x52, 0x45, 0x41,
        0x44, 0x59, 0x5f, 0x45, 0x58, 0x49, 0x53, 0x54, 0x53, 0x10, 0x03, 0x12, 0x17, 0x0a, 0x13, 0x45,
        0x52, 0x52, 0x4f, 0x52, 0x5f, 0x54, 0x4f, 0x4b, 0x45, 0x4e, 0x5f, 0x45, 0x58, 0x50, 0x49, 0x52,
        0x45, 0x44, 0x10, 0x04, 0x12, 0x1b, 0x0a, 0x17, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x5f, 0x50, 0x45,
        0x52, 0x4d, 0x49, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x45, 0x4e, 0x49, 0x45, 0x44, 0x10,
        0x05, 0x32, 0xcb, 0x03, 0x0a, 0x0b, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x3b, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x12, 0x16, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65,
        0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40,
        0x0a, 0x0b, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x42, 0x79, 0x49, 0x44, 0x12, 0x15, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x32, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x47, 0x0a, 0x0c, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54,
        0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x66,
        0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68,
        0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a,
        0x0d, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x16,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56,
        0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x35, 0x0a, 0x06, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x14, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x15, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x47, 0x0a, 0x10, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41,
        0x64, 0x6d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x68, 0x65,
        0x63, 0x6b, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32,
        0x9a, 0x07, 0x0a, 0x0c, 0x46, 0x6f, 0x72, 0x75, 0x6d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x12, 0x43, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x66, 0x69,
        0x6c, 0x65, 0x12, 0x15, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73,
        0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x49, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55,
        0x73, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x18, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x3b, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x74, 0x12, 0x18,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x73,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x35, 0x0a,
        0x07, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x73, 0x74, 0x12, 0x15, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3b, 0x0a, 0x0a, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x6f,
        0x73, 0x74, 0x12, 0x18, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x3b, 0x0a, 0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x74, 0x12,
        0x18, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x6f,
        0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x3a,
        0x0a, 0x05, 0x50, 0x6f, 0x73, 0x74, 0x73, 0x12, 0x17, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x4c, 0x69, 0x73, 0x74, 0x50, 0x6f, 0x73, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x18, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x6f, 0x73,
        0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0d, 0x43, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x3e, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x18,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x43, 0x0a, 0x08, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x1a, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43,
        0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
        0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x0d, 0x44,
        0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x65,
        0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x36,
        0x0a, 0x0b, 0x53, 0x65, 0x6e, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x68, 0x61, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x1a, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x4d,
        0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x44, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x19, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x47, 0x65,
        0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x0c, 0x5a, 0x0a,
        0x62, 0x61, 0x63, 0x6b, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_proto_forum_proto_rawDescOnce sync.Once
        file_proto_forum_proto_rawDescData = file_proto_forum_proto_rawDesc
)

func file_proto_forum_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_forum_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_forum_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_forum_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_forum_proto_rawDescData</span>
}

var file_proto_forum_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_forum_proto_msgTypes = make([]protoimpl.MessageInfo, 38)
var file_proto_forum_proto_goTypes = []interface{}{
        (ErrorCode)(0),               // 0: proto.ErrorCode
        (*EmptyMessage)(nil),         // 1: proto.EmptyMessage
        (*RegisterRequest)(nil),      // 2: proto.RegisterRequest
        (*RegisterResponse)(nil),     // 3: proto.RegisterResponse
        (*LoginRequest)(nil),         // 4: proto.LoginRequest
        (*LoginResponse)(nil),        // 5: proto.LoginResponse
        (*RefreshTokenRequest)(nil),  // 6: proto.RefreshTokenRequest
        (*RefreshTokenResponse)(nil), // 7: proto.RefreshTokenResponse
        (*ValidateRequest)(nil),      // 8: proto.ValidateRequest
        (*ValidateResponse)(nil),     // 9: proto.ValidateResponse
        (*LogoutRequest)(nil),        // 10: proto.LogoutRequest
        (*LogoutResponse)(nil),       // 11: proto.LogoutResponse
        (*Post)(nil),                 // 12: proto.Post
        (*PostResponse)(nil),         // 13: proto.PostResponse
        (*CreatePostRequest)(nil),    // 14: proto.CreatePostRequest
        (*GetPostRequest)(nil),       // 15: proto.GetPostRequest
        (*UpdatePostRequest)(nil),    // 16: proto.UpdatePostRequest
        (*DeletePostRequest)(nil),    // 17: proto.DeletePostRequest
        (*ListPostsRequest)(nil),     // 18: proto.ListPostsRequest
        (*ListPostsResponse)(nil),    // 19: proto.ListPostsResponse
        (*Comment)(nil),              // 20: proto.Comment
        (*CommentResponse)(nil),      // 21: proto.CommentResponse
        (*CreateCommentRequest)(nil), // 22: proto.CreateCommentRequest
        (*GetCommentRequest)(nil),    // 23: proto.GetCommentRequest
        (*ListCommentsRequest)(nil),  // 24: proto.ListCommentsRequest
        (*ListCommentsResponse)(nil), // 25: proto.ListCommentsResponse
        (*UpdateCommentRequest)(nil), // 26: proto.UpdateCommentRequest
        (*DeleteCommentRequest)(nil), // 27: proto.DeleteCommentRequest
        (*ChatMessage)(nil),          // 28: proto.ChatMessage
        (*GetMessagesRequest)(nil),   // 29: proto.GetMessagesRequest
        (*GetMessagesResponse)(nil),  // 30: proto.GetMessagesResponse
        (*ChatConfig)(nil),           // 31: proto.ChatConfig
        (*User)(nil),                 // 32: proto.User
        (*GetUserRequest)(nil),       // 33: proto.GetUserRequest
        (*UserProfileResponse)(nil),  // 34: proto.UserProfileResponse
        (*UpdateUserRequest)(nil),    // 35: proto.UpdateUserRequest
        (*Error)(nil),                // 36: proto.Error
        (*CheckAdminRequest)(nil),    // 37: proto.CheckAdminRequest
        (*CheckAdminResponse)(nil),   // 38: proto.CheckAdminResponse
}
var file_proto_forum_proto_depIdxs = []int32{
        34, // 0: proto.LoginResponse.user:type_name -&gt; proto.UserProfileResponse
        12, // 1: proto.PostResponse.post:type_name -&gt; proto.Post
        12, // 2: proto.ListPostsResponse.posts:type_name -&gt; proto.Post
        20, // 3: proto.CommentResponse.comment:type_name -&gt; proto.Comment
        20, // 4: proto.ListCommentsResponse.comments:type_name -&gt; proto.Comment
        28, // 5: proto.GetMessagesResponse.messages:type_name -&gt; proto.ChatMessage
        0,  // 6: proto.Error.code:type_name -&gt; proto.ErrorCode
        2,  // 7: proto.AuthService.Register:input_type -&gt; proto.RegisterRequest
        33, // 8: proto.AuthService.GetUserByID:input_type -&gt; proto.GetUserRequest
        4,  // 9: proto.AuthService.Login:input_type -&gt; proto.LoginRequest
        6,  // 10: proto.AuthService.RefreshToken:input_type -&gt; proto.RefreshTokenRequest
        8,  // 11: proto.AuthService.ValidateToken:input_type -&gt; proto.ValidateRequest
        10, // 12: proto.AuthService.Logout:input_type -&gt; proto.LogoutRequest
        37, // 13: proto.AuthService.CheckAdminStatus:input_type -&gt; proto.CheckAdminRequest
        33, // 14: proto.ForumService.GetUserProfile:input_type -&gt; proto.GetUserRequest
        35, // 15: proto.ForumService.UpdateUserProfile:input_type -&gt; proto.UpdateUserRequest
        14, // 16: proto.ForumService.CreatePost:input_type -&gt; proto.CreatePostRequest
        15, // 17: proto.ForumService.GetPost:input_type -&gt; proto.GetPostRequest
        16, // 18: proto.ForumService.UpdatePost:input_type -&gt; proto.UpdatePostRequest
        17, // 19: proto.ForumService.DeletePost:input_type -&gt; proto.DeletePostRequest
        18, // 20: proto.ForumService.Posts:input_type -&gt; proto.ListPostsRequest
        22, // 21: proto.ForumService.CreateComment:input_type -&gt; proto.CreateCommentRequest
        23, // 22: proto.ForumService.GetComment:input_type -&gt; proto.GetCommentRequest
        24, // 23: proto.ForumService.Comments:input_type -&gt; proto.ListCommentsRequest
        26, // 24: proto.ForumService.UpdateComment:input_type -&gt; proto.UpdateCommentRequest
        27, // 25: proto.ForumService.DeleteComment:input_type -&gt; proto.DeleteCommentRequest
        28, // 26: proto.ForumService.SendMessage:input_type -&gt; proto.ChatMessage
        29, // 27: proto.ForumService.GetMessages:input_type -&gt; proto.GetMessagesRequest
        3,  // 28: proto.AuthService.Register:output_type -&gt; proto.RegisterResponse
        34, // 29: proto.AuthService.GetUserByID:output_type -&gt; proto.UserProfileResponse
        5,  // 30: proto.AuthService.Login:output_type -&gt; proto.LoginResponse
        7,  // 31: proto.AuthService.RefreshToken:output_type -&gt; proto.RefreshTokenResponse
        9,  // 32: proto.AuthService.ValidateToken:output_type -&gt; proto.ValidateResponse
        11, // 33: proto.AuthService.Logout:output_type -&gt; proto.LogoutResponse
        38, // 34: proto.AuthService.CheckAdminStatus:output_type -&gt; proto.CheckAdminResponse
        34, // 35: proto.ForumService.GetUserProfile:output_type -&gt; proto.UserProfileResponse
        34, // 36: proto.ForumService.UpdateUserProfile:output_type -&gt; proto.UserProfileResponse
        13, // 37: proto.ForumService.CreatePost:output_type -&gt; proto.PostResponse
        13, // 38: proto.ForumService.GetPost:output_type -&gt; proto.PostResponse
        13, // 39: proto.ForumService.UpdatePost:output_type -&gt; proto.PostResponse
        1,  // 40: proto.ForumService.DeletePost:output_type -&gt; proto.EmptyMessage
        19, // 41: proto.ForumService.Posts:output_type -&gt; proto.ListPostsResponse
        21, // 42: proto.ForumService.CreateComment:output_type -&gt; proto.CommentResponse
        21, // 43: proto.ForumService.GetComment:output_type -&gt; proto.CommentResponse
        25, // 44: proto.ForumService.Comments:output_type -&gt; proto.ListCommentsResponse
        21, // 45: proto.ForumService.UpdateComment:output_type -&gt; proto.CommentResponse
        1,  // 46: proto.ForumService.DeleteComment:output_type -&gt; proto.EmptyMessage
        1,  // 47: proto.ForumService.SendMessage:output_type -&gt; proto.EmptyMessage
        30, // 48: proto.ForumService.GetMessages:output_type -&gt; proto.GetMessagesResponse
        28, // [28:49] is the sub-list for method output_type
        7,  // [7:28] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_forum_proto_init() }</span>
func file_proto_forum_proto_init() <span class="cov8" title="1">{
        if File_proto_forum_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_proto_forum_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EmptyMessage); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ValidateRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ValidateResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LogoutRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LogoutResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Post); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PostResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreatePostRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetPostRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdatePostRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeletePostRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListPostsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListPostsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Comment); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CommentResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateCommentRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetCommentRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListCommentsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListCommentsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateCommentRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteCommentRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ChatMessage); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMessagesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetMessagesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ChatConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*User); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserProfileResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Error); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CheckAdminRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_forum_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CheckAdminResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_proto_forum_proto_msgTypes[15].OneofWrappers = []interface{}{}
        file_proto_forum_proto_msgTypes[17].OneofWrappers = []interface{}{}
        file_proto_forum_proto_msgTypes[25].OneofWrappers = []interface{}{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_forum_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   38,
                        NumExtensions: 0,
                        NumServices:   2,
                },
                GoTypes:           file_proto_forum_proto_goTypes,
                DependencyIndexes: file_proto_forum_proto_depIdxs,
                EnumInfos:         file_proto_forum_proto_enumTypes,
                MessageInfos:      file_proto_forum_proto_msgTypes,
        }.Build()
        File_proto_forum_proto = out.File
        file_proto_forum_proto_rawDesc = nil
        file_proto_forum_proto_goTypes = nil
        file_proto_forum_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v6.30.2
// source: proto/forum.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        // Register creates a new user account
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        GetUserByID(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error)
        // Login authenticates user and returns access/refresh tokens
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
        ValidateToken(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
        CheckAdminStatus(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (*CheckAdminResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/Register", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetUserByID(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error) <span class="cov0" title="0">{
        out := new(UserProfileResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/GetUserByID", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/Login", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        out := new(RefreshTokenResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/RefreshToken", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) <span class="cov0" title="0">{
        out := new(ValidateResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/ValidateToken", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/Logout", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) CheckAdminStatus(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (*CheckAdminResponse, error) <span class="cov0" title="0">{
        out := new(CheckAdminResponse)
        err := c.cc.Invoke(ctx, "/proto.AuthService/CheckAdminStatus", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
        // Register creates a new user account
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        GetUserByID(context.Context, *GetUserRequest) (*UserProfileResponse, error)
        // Login authenticates user and returns access/refresh tokens
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
        ValidateToken(context.Context, *ValidateRequest) (*ValidateResponse, error)
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        CheckAdminStatus(context.Context, *CheckAdminRequest) (*CheckAdminResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetUserByID(context.Context, *GetUserRequest) (*UserProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserByID not implemented")
}</span>
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateRequest) (*ValidateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServiceServer) CheckAdminStatus(context.Context, *CheckAdminRequest) (*CheckAdminResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CheckAdminStatus not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;AuthService_ServiceDesc, srv)
}</span>

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/Register",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/GetUserByID",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserByID(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/Login",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/RefreshToken",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ValidateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/ValidateToken",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/Logout",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_CheckAdminStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CheckAdminRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckAdminStatus(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.AuthService/CheckAdminStatus",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckAdminStatus(ctx, req.(*CheckAdminRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "proto.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _AuthService_Register_Handler,
                },
                {
                        MethodName: "GetUserByID",
                        Handler:    _AuthService_GetUserByID_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "RefreshToken",
                        Handler:    _AuthService_RefreshToken_Handler,
                },
                {
                        MethodName: "ValidateToken",
                        Handler:    _AuthService_ValidateToken_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _AuthService_Logout_Handler,
                },
                {
                        MethodName: "CheckAdminStatus",
                        Handler:    _AuthService_CheckAdminStatus_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/forum.proto",
}

// ForumServiceClient is the client API for ForumService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ForumServiceClient interface {
        // User operations
        GetUserProfile(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error)
        UpdateUserProfile(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error)
        // Post operations
        CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        UpdatePost(ctx context.Context, in *UpdatePostRequest, opts ...grpc.CallOption) (*PostResponse, error)
        DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*EmptyMessage, error)
        Posts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error)
        // Comment operations
        CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        Comments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error)
        UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
        DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*EmptyMessage, error)
        // Chat operations
        SendMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*EmptyMessage, error)
        GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
}

type forumServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewForumServiceClient(cc grpc.ClientConnInterface) ForumServiceClient <span class="cov0" title="0">{
        return &amp;forumServiceClient{cc}
}</span>

func (c *forumServiceClient) GetUserProfile(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error) <span class="cov0" title="0">{
        out := new(UserProfileResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/GetUserProfile", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) UpdateUserProfile(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserProfileResponse, error) <span class="cov0" title="0">{
        out := new(UserProfileResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/UpdateUserProfile", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/CreatePost", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/GetPost", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) UpdatePost(ctx context.Context, in *UpdatePostRequest, opts ...grpc.CallOption) (*PostResponse, error) <span class="cov0" title="0">{
        out := new(PostResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/UpdatePost", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) DeletePost(ctx context.Context, in *DeletePostRequest, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, "/proto.ForumService/DeletePost", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) Posts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error) <span class="cov0" title="0">{
        out := new(ListPostsResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/Posts", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/CreateComment", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/GetComment", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) Comments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        out := new(ListCommentsResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/Comments", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) <span class="cov0" title="0">{
        out := new(CommentResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/UpdateComment", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, "/proto.ForumService/DeleteComment", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) SendMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*EmptyMessage, error) <span class="cov0" title="0">{
        out := new(EmptyMessage)
        err := c.cc.Invoke(ctx, "/proto.ForumService/SendMessage", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *forumServiceClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) <span class="cov0" title="0">{
        out := new(GetMessagesResponse)
        err := c.cc.Invoke(ctx, "/proto.ForumService/GetMessages", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ForumServiceServer is the server API for ForumService service.
// All implementations must embed UnimplementedForumServiceServer
// for forward compatibility
type ForumServiceServer interface {
        // User operations
        GetUserProfile(context.Context, *GetUserRequest) (*UserProfileResponse, error)
        UpdateUserProfile(context.Context, *UpdateUserRequest) (*UserProfileResponse, error)
        // Post operations
        CreatePost(context.Context, *CreatePostRequest) (*PostResponse, error)
        GetPost(context.Context, *GetPostRequest) (*PostResponse, error)
        UpdatePost(context.Context, *UpdatePostRequest) (*PostResponse, error)
        DeletePost(context.Context, *DeletePostRequest) (*EmptyMessage, error)
        Posts(context.Context, *ListPostsRequest) (*ListPostsResponse, error)
        // Comment operations
        CreateComment(context.Context, *CreateCommentRequest) (*CommentResponse, error)
        GetComment(context.Context, *GetCommentRequest) (*CommentResponse, error)
        Comments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error)
        UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error)
        DeleteComment(context.Context, *DeleteCommentRequest) (*EmptyMessage, error)
        // Chat operations
        SendMessage(context.Context, *ChatMessage) (*EmptyMessage, error)
        GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
        mustEmbedUnimplementedForumServiceServer()
}

// UnimplementedForumServiceServer must be embedded to have forward compatible implementations.
type UnimplementedForumServiceServer struct {
}

func (UnimplementedForumServiceServer) GetUserProfile(context.Context, *GetUserRequest) (*UserProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserProfile not implemented")
}</span>
func (UnimplementedForumServiceServer) UpdateUserProfile(context.Context, *UpdateUserRequest) (*UserProfileResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUserProfile not implemented")
}</span>
func (UnimplementedForumServiceServer) CreatePost(context.Context, *CreatePostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}</span>
func (UnimplementedForumServiceServer) GetPost(context.Context, *GetPostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}</span>
func (UnimplementedForumServiceServer) UpdatePost(context.Context, *UpdatePostRequest) (*PostResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}</span>
func (UnimplementedForumServiceServer) DeletePost(context.Context, *DeletePostRequest) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}</span>
func (UnimplementedForumServiceServer) Posts(context.Context, *ListPostsRequest) (*ListPostsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Posts not implemented")
}</span>
func (UnimplementedForumServiceServer) CreateComment(context.Context, *CreateCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateComment not implemented")
}</span>
func (UnimplementedForumServiceServer) GetComment(context.Context, *GetCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetComment not implemented")
}</span>
func (UnimplementedForumServiceServer) Comments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Comments not implemented")
}</span>
func (UnimplementedForumServiceServer) UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateComment not implemented")
}</span>
func (UnimplementedForumServiceServer) DeleteComment(context.Context, *DeleteCommentRequest) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}</span>
func (UnimplementedForumServiceServer) SendMessage(context.Context, *ChatMessage) (*EmptyMessage, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}</span>
func (UnimplementedForumServiceServer) GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}</span>
func (UnimplementedForumServiceServer) mustEmbedUnimplementedForumServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeForumServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForumServiceServer will
// result in compilation errors.
type UnsafeForumServiceServer interface {
        mustEmbedUnimplementedForumServiceServer()
}

func RegisterForumServiceServer(s grpc.ServiceRegistrar, srv ForumServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;ForumService_ServiceDesc, srv)
}</span>

func _ForumService_GetUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetUserProfile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/GetUserProfile",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetUserProfile(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_UpdateUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateUserProfile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/UpdateUserProfile",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateUserProfile(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreatePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreatePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/CreatePost",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreatePost(ctx, req.(*CreatePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetPost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/GetPost",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetPost(ctx, req.(*GetPostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdatePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdatePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/UpdatePost",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdatePost(ctx, req.(*UpdatePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeletePostRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeletePost(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/DeletePost",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeletePost(ctx, req.(*DeletePostRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_Posts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListPostsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Posts(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/Posts",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Posts(ctx, req.(*ListPostsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreateComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/CreateComment",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).CreateComment(ctx, req.(*CreateCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/GetComment",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetComment(ctx, req.(*GetCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_Comments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListCommentsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Comments(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/Comments",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).Comments(ctx, req.(*ListCommentsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_UpdateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/UpdateComment",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).UpdateComment(ctx, req.(*UpdateCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteCommentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeleteComment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/DeleteComment",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ChatMessage)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).SendMessage(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/SendMessage",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).SendMessage(ctx, req.(*ChatMessage))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ForumService_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMessagesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetMessages(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/proto.ForumService/GetMessages",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ForumServiceServer).GetMessages(ctx, req.(*GetMessagesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ForumService_ServiceDesc is the grpc.ServiceDesc for ForumService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ForumService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "proto.ForumService",
        HandlerType: (*ForumServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetUserProfile",
                        Handler:    _ForumService_GetUserProfile_Handler,
                },
                {
                        MethodName: "UpdateUserProfile",
                        Handler:    _ForumService_UpdateUserProfile_Handler,
                },
                {
                        MethodName: "CreatePost",
                        Handler:    _ForumService_CreatePost_Handler,
                },
                {
                        MethodName: "GetPost",
                        Handler:    _ForumService_GetPost_Handler,
                },
                {
                        MethodName: "UpdatePost",
                        Handler:    _ForumService_UpdatePost_Handler,
                },
                {
                        MethodName: "DeletePost",
                        Handler:    _ForumService_DeletePost_Handler,
                },
                {
                        MethodName: "Posts",
                        Handler:    _ForumService_Posts_Handler,
                },
                {
                        MethodName: "CreateComment",
                        Handler:    _ForumService_CreateComment_Handler,
                },
                {
                        MethodName: "GetComment",
                        Handler:    _ForumService_GetComment_Handler,
                },
                {
                        MethodName: "Comments",
                        Handler:    _ForumService_Comments_Handler,
                },
                {
                        MethodName: "UpdateComment",
                        Handler:    _ForumService_UpdateComment_Handler,
                },
                {
                        MethodName: "DeleteComment",
                        Handler:    _ForumService_DeleteComment_Handler,
                },
                {
                        MethodName: "SendMessage",
                        Handler:    _ForumService_SendMessage_Handler,
                },
                {
                        MethodName: "GetMessages",
                        Handler:    _ForumService_GetMessages_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/forum.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
